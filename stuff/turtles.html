<html>
    <head>
        <title>Turtles</title>
        <link rel="stylesheet" type="text/css" href="../style.css">
    </head>

    <body>
        <!--input textarea and a canvas with dark gray default color, button to render-->
        <canvas class="genericCanvas" id="canvas" width="640" height="640"></canvas>
        <p>available instructions: move [x,y]; wait [time]</p>
        <textarea id="input" rows="10" cols="50"></textarea>
    </br>
        <button id="spawn">Spawn</button>

    <script src="./turtle_ai.js"></script>

    <script>
        //import AI from turtle_ai.js file

        class tile{
            constructor(type,x,y){
                this.type = type;
                this.payload = null;
                this.x = x;
                this.y = y;
                this.highlighted=false;
                this.changed=false;
            }
            get blocked(){
                let blocked=(this.payload!=null)||(this.type=="wall");
                return blocked;
            }
            enter(payload){
                this.payload = payload;
                this.changed=true;
            }
            leave(){
                this.payload = null;
            }
            update(){
            };
            render(){
                if(this.payload){this.payload.render();}
            };
        }
        class World{
            constructor(width,height, canvas)
            {
                this.canvas = canvas;
                this.width = width;
                this.height = height;
                this.tiles = [];
                for(let x=0;x<width;x++)
                {
                    this.tiles[x] = [];
                    for(let y=0;y<height;y++)
                    {
                        this.tiles[x][y] = new tile("empty",x,y);
                    }
                }
            }
            update(){
                for(let x=0;x<this.width;x++)
                {
                    for(let y=0;y<this.height;y++)
                    {
                        this.tiles[x][y].update();
                    }
                }
            }
            getTile(x,y){
                return this.tiles[x][y];
            }
            highlight(x,y){
                this.getTile(x,y).highlighted=true;
            }

            getNeighbors(tile){
                let neighbors = [];
                //all 8 neighbors
                //direction "0" is up, from there clockwise
                for(let direction=0;direction<8;direction++){
                    let x = tile.x;
                    let y = tile.y;
                    switch(direction){
                        case 0:
                            y--;
                            break;
                        case 1:
                            x++;
                            y--;
                            break;
                        case 2:
                            x++;
                            break;
                        case 3:
                            x++;
                            y++;
                            break;
                        case 4:
                            y++;
                            break;
                        case 5:
                            x--;
                            y++;
                            break;
                        case 6:
                            x--;
                            break;
                        case 7:
                            x--;
                            y--;
                            break;
                    }
                    if(x>=0&&x<this.width&&y>=0&&y<this.height){
                        neighbors.push(this.getTile(x,y));
                    } else {
                        neighbors.push(null);
                    }
                }

                return neighbors;
            }

            //render the world to given canvas, empty tiles are rendered as gray, others as red
            render(){
                let canvas=this.canvas;
                let ctx = canvas.getContext("2d");
                ctx.clearRect(0,0,canvas.width,canvas.height);
                for(let x=0;x<this.width;x++)
                {
                    for(let y=0;y<this.height;y++)
                    {
                        //draw tile

                        let tile = this.tiles[x][y];
                        if(tile.blocked)
                        {
                            ctx.fillStyle = "red";
                            ctx.fillRect(x*10,y*10,10,10);
                        }
                        else
                        {
                            ctx.fillStyle = "darkgray";
                            ctx.fillRect(x*10,y*10,10,10);
                            if(this.tiles[x][y].highlighted)
                        {
                            ctx.fillStyle = "green";
                            ctx.fillRect(x*10,y*10,10,10);
                            this.tiles[x][y].highlighted=false;
                        }
                        }

                    }
                }
            }

        }
        
        


        class Robot {
            constructor(x, y, id, world,ai="") {
                this.rotation = 0;
                this.world = world;
                this.x = x;
                this.y = y;
                this.targetX = x;
                this.targetY = y;
                this.id = id;
                this.ai=new AI(ai,world,this);
            }

            get tile(){
                return this.world.getTile(Math.floor(this.x),Math.floor(this.y));
            }
            update(){
                this.ai.tick();
                //if distance to target is less than 1, set current position to target
                let distance = Math.sqrt(Math.pow(this.targetX-this.x,2)+Math.pow(this.targetY-this.y,2));
                if(distance<1){
                    this.x=this.targetX;
                    this.y=this.targetY;
                    return;
                }
                //get angle to target
                let angle = Math.atan2(this.targetY-this.y,this.targetX-this.x);
                //set rotation to angle
                this.rotation = angle;
                //move forward
                let textX=Math.floor(2*(this.x+Math.cos(angle)))/2;
                let testY=Math.floor(2*(this.y+Math.sin(angle)))/2;
                if(!this.world.getTile(Math.floor(textX),Math.floor(testY)).blocked){
                    this.x = textX;
                    this.y = testY;
                }
            }

            move(targetX,targetY){
                //math.max/min with world bounds
                this.targetX = Math.max(0,Math.min(targetX,this.world.width-1));
                this.targetY = Math.max(0,Math.min(targetY,this.world.height-1));
            }
            render(){
                let ctx = this.world.canvas.getContext("2d");
                ctx.fillStyle = "blue";
                ctx.beginPath();
                ctx.arc(this.x*10+5,this.y*10+5,5,0,2*Math.PI);
                ctx.fill();
                ctx.fillStyle = "red";
                ctx.beginPath();
                ctx.arc(this.x*10+5,this.y*10+5,2,0,2*Math.PI);
                ctx.fill();
                ctx.fillStyle = "black";
                ctx.beginPath();
                ctx.arc(this.x*10+5,this.y*10+5,1,0,2*Math.PI);
                ctx.fill();
                ctx.fillStyle = "black";
                ctx.beginPath();
                ctx.arc(this.x*10+5,this.y*10+5,0.5,0,2*Math.PI);
                ctx.fill();
                ctx.fillStyle = "black";
                ctx.beginPath();
                ctx.arc(this.x*10+5,this.y*10+5,0.25,0,2*Math.PI);
                ctx.fill();
                ctx.fillStyle = "black";
                ctx.beginPath();
                ctx.arc(this.x*10+5,this.y*10+5,0.125,0,2*Math.PI);
                ctx.fill();
                ctx.fillStyle = "black";
                ctx.beginPath();
                ctx.arc(this.x*10+5,this.y*10+5,0.0625,0,2*Math.PI);
                ctx.fill();
                ctx.fillStyle = "black";
                ctx.beginPath();
                ctx.arc(this.x*10+5,this.y*10+5,0.03125,0,2*Math.PI);
                ctx.fill();
                ctx.fillStyle = "black";
                ctx.beginPath();
                ctx.arc(this.x*10+5,this.y*10+5,0.015625,0,2*Math.PI);
                ctx.fill();

                //draw a dotted line from current position to target
                ctx.strokeStyle = "black";
                ctx.beginPath();
                ctx.moveTo(this.x*10+5,this.y*10+5);
                ctx.lineTo(this.targetX*10+5,this.targetY*10+5);
                ctx.setLineDash([5,5]);
                ctx.stroke();
                ctx.setLineDash([]);


            }
        }
        //canvas
        let canvas = document.getElementById("canvas");
        const world=new World(64,64,canvas);
        let turtles=[];

        function globalTick(){
            //console.log("update");
            let startTime=Date.now();

            //call update on all turtles
            world.render();
            for(let turtle of turtles){
                turtle.update();
                turtle.render();
            }

            world.update();
            //console.log("render");
            console.log(Date.now()-startTime);  
        };
        setInterval(globalTick,100);

        //spawn robot on button click using input box string as AI
        
        document.getElementById("spawn").addEventListener("click",function(){
            let ai = document.getElementById("input").value;
            let robot = new Robot(50,50,0,world,ai);
            turtles.push(robot);
        });




    </script>
    </body>

</html>