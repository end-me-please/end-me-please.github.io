<html>
    <head>
        <script src="./heightmap.js"></script>
        <script src="https://cdn.babylonjs.com/babylon.js"></script>
        <script src="https://cdn.babylonjs.com/loaders/babylon.objFileLoader.js"></script>
        <script src="https://cdn.babylonjs.com/gui/babylon.gui.js"></script>
        <script src="https://cdn.rawgit.com/BabylonJS/Extensions/master/DynamicTerrain/dist/babylon.dynamicTerrain.min.js"></script>
    </head>
    
    <body>

        <canvas id="noisemapTest" width="512" height="512"></canvas>








    </body>
    <script>
        let pressedKeys = {};
        const chunkSize = 54;
        const renderDistance = 9;
        const mapScale = 1;


        document.addEventListener('keydown', function(event){
            if(!event.key.startsWith('F')) event.preventDefault()
            else return;
            
            pressedKeys[event.key] = true;
            //if not a "function" key, prevent default action
        });
        document.addEventListener('keyup', function(event){
            if(!event.key.startsWith('F')) event.preventDefault()
            else return;
            pressedKeys[event.key] = false;
        });


        let canvas = document.getElementById("noisemapTest");
        //full screen canvas
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        let map = new Terrain(0.4);
        let engine = new BABYLON.Engine(canvas, true, {preserveDrawingBuffer: true, stencil: true});
        
        function setupScene() {
            
            let scene = new BABYLON.Scene(engine);
            let camera = new BABYLON.UniversalCamera('camera1', new BABYLON.Vector3(500, 5, 500), scene);
            camera.minZ = 0.1;
            scene.metadata = {};
            //scene.debugLayer.show();

            //add instrumentation- angle of attack, speed, etc
            let advancedTexture = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI");
            let text1 = new BABYLON.GUI.TextBlock();
            text1.text = "Angle of Attack: 0";
            text1.color = "white";
            text1.fontSize = 14;
            text1.textHorizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;
            text1.textVerticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP;
            advancedTexture.addControl(text1);
            scene.metadata.hud = text1;
            //alpha
            text1.alpha = 0.5;


            //top right: low alpha text with controls
            let text2 = new BABYLON.GUI.TextBlock();
            text2.text = "Controls:\nWASD: Pitch, Yaw\nQE: Roll\nSpace: Accelerate\nB: Brake\n Angle of Attack above 15째 will cause stall";
            text2.color = "white";
            text2.fontSize = 14;
            text2.textHorizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_RIGHT;
            text2.textVerticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP;
            text2.alpha = 0.5;
            advancedTexture.addControl(text2);
            
            //performance gui element stored in scene.metadata.performance
            //text element
            let text3 = new BABYLON.GUI.TextBlock();
            text3.text = "Performance: 0";
            text3.color = "white";
            text3.fontSize = 14;
            text3.textHorizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;
            text3.textVerticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_BOTTOM;
            advancedTexture.addControl(text3);
            scene.metadata.performance = text3;
            //alpha
            text3.alpha = 0.5;



            //directional light
            let light = new BABYLON.DirectionalLight("dir01", new BABYLON.Vector3(0.3, -0.45, -1), scene);
            light.intensity = 1;
            //hemispheric light
            let light2 = new BABYLON.HemisphericLight("HemiLight", new BABYLON.Vector3(0, 1, 0), scene);
            light2.intensity = 0.6;

            //scene color to black
            scene.clearColor = new BABYLON.Color3(0, 0, 0);


            //only init these materials once
            let groundMaterial = new BABYLON.StandardMaterial("groundMaterialWireframe", scene);
            groundMaterial.wireframe = true;
            groundMaterial.diffuseColor = new BABYLON.Color3(0.3, 0.87, 0.2);
            groundMaterial.specularColor = new BABYLON.Color3(0, 0, 0);
            groundMaterial.alpha = 0.5;
            let groundMaterial2 = new BABYLON.StandardMaterial("groundMaterialBlack", scene);
            groundMaterial2.wireframe = false;
            groundMaterial2.diffuseColor = new BABYLON.Color3(0, 0, 0);
            groundMaterial2.specularColor = new BABYLON.Color3(0, 0, 0);
            groundMaterial2.alpha = 1;
            let mountainMaterial = new BABYLON.StandardMaterial("mountainMaterialWireframe", scene);
            mountainMaterial.wireframe = false;
            mountainMaterial.diffuseColor = new BABYLON.Color3(0.8, 0.7, 0.85);
            mountainMaterial.specularColor = new BABYLON.Color3(0, 0.03, 0);
            //line texture (dynamic texture)
            let textureResolution = 512;
            let texture = new BABYLON.DynamicTexture("dynamic texture", {width: textureResolution, height: textureResolution}, scene);
            let textureContext = texture.getContext();
            let size = texture.getSize();
            //draw a grid of purple lines with gray background
            textureContext.fillStyle = "rgb(0,5,1)";
            textureContext.fillRect(0, 0, size.width, size.height);
            textureContext.strokeStyle = "rgb(150,60,150)";
            textureContext.lineWidth = 1;
            for(let i = 0; i < size.width; i += 12) {
                textureContext.beginPath();
                textureContext.moveTo(i, 0);
                textureContext.lineTo(i, size.height);
                textureContext.stroke();
            }
            for(let i = 0; i < size.height; i += 8) {
                textureContext.beginPath();
                textureContext.moveTo(0, i);
                textureContext.lineTo(size.width, i);
                textureContext.stroke();
            }
            //update texture

            texture.update();
            mountainMaterial.diffuseTexture = texture;



            mountainMaterial.alpha = 1;
            let mountainMaterial2 = new BABYLON.StandardMaterial("mountainMaterialBlack", scene);
            mountainMaterial2.wireframe = false;
            mountainMaterial2.diffuseColor = new BABYLON.Color3(0, 0, 0);
            mountainMaterial2.specularColor = new BABYLON.Color3(0, 0, 0);
            mountainMaterial2.alpha = 1;
            
            scene.metadata.materials = {
                groundMaterialWireframe: groundMaterial,
                groundMaterialBlack: groundMaterial2,
                mountainMaterialWireframe: mountainMaterial,
                mountainMaterialBlack: mountainMaterial2
            }




















            scene.metadata.chunks = [];
            //generate chunks in y direction
            
            scene.metadata.ships = [];

            //use objfileloader to load ship1.obj
            BABYLON.SceneLoader.ImportMesh("", "./", "ship1.obj", scene, function(newMeshes){

                //material
                newMeshes[0].material = new BABYLON.StandardMaterial("shipMaterial", scene);
                newMeshes[0].material.diffuseColor = new BABYLON.Color3(0.4, 0.6, 0.8);
                newMeshes[0].material.specularColor = new BABYLON.Color3(0, 0, 0);
                newMeshes[0].material.emissiveColor = new BABYLON.Color3(0.2, 0.4, 0.4);
                //wireframe
                newMeshes[0].material.wireframe = true;


                //add to scene metadata
                scene.metadata.ships.push(new Ship(newMeshes[0], scene));
            });

            


            let params = {
                width: 100,
                height: 100,

            }
            let terrain = new BABYLON.DynamicTerrain("terrain", params, scene);
            //set custom vertex update function
            terrain.useCustomVertexFunction = true;
            terrain.updateVertex = function(vertex, i, j) {

                let mapResult = map.get(vertex.worldPosition.x,vertex.worldPosition.z);

                //set position according to i, j and map(i,j)
                vertex.position.y = mapResult*60;
                //set color according to height
                if(mapResult<0.005){
                    vertex.color.r = 0.3;
                    vertex.color.g = 1;
                    vertex.color.b = 0.2;
                } else {
                    vertex.color.r = 0.8;
                    vertex.color.g = 0.1;
                    vertex.color.b = 0.8;
                }


            }
            terrain.subToleranceX = 2;
            terrain.subToleranceZ = 2;
            terrain.initialLOD = 3;
            //offset terrain, shiftFromCamera.x
            terrain.shiftFromCamera.x = -params.width/2;
            terrain.shiftFromCamera.z = -params.height/2;



            terrain.mesh.material = mountainMaterial;

            scene.metadata.terrain = terrain;
            return scene;
        }
        class Ship {
            constructor(mesh, scene){
                this.mesh = mesh;
                this.rotation = mesh.rotation;
                this.position = mesh.position;
                this.position.x = 15;
                this.position.y = 20;
                this.position.z = 15;
                this.velocity = new BABYLON.Vector3(0,0,0.8);
                this.controls = {
                    rotationInput: new BABYLON.Vector3(0,0,0),
                    throttleInput: 0,
                    brakeInput: 0,
                };
                this.engineParticles = new BABYLON.GPUParticleSystem("particles", 2500, scene);
                this.engineParticles.emitter = this.mesh;
                //size
                this.engineParticles.minSize = 0.02;
                this.engineParticles.maxSize = 0.08;
                //lifetime
                this.engineParticles.minLifeTime = 2;
                this.engineParticles.maxLifeTime = 6;
                //low divergence of particles, straight beam backwards


                //emitrate
                this.engineParticles.emitRate = 1;
                //texture particle.bmp
                this.engineParticles.particleTexture = new BABYLON.Texture("particle.bmp", scene);
                //direction
                this.engineParticles.direction1 = new BABYLON.Vector3(-0.1, 0, -0.1);
                this.engineParticles.direction2 = new BABYLON.Vector3(0.1, 0, 0.1);
                //update rate
                this.engineParticles.updateSpeed = 0.01;

                this.engineParticles.start();

                //use baking transform to flip ship
                this.mesh.bakeTransformIntoVertices(BABYLON.Matrix.RotationY(Math.PI));
                //use setPivotPoint(vec3)
                this.mesh.setPivotPoint(new BABYLON.Vector3(0,0.9,0));
            


            }
        }

        var scene = setupScene();
        
        let instrumentation = new BABYLON.SceneInstrumentation(scene);
        instrumentation.captureFrameTime = true;
        instrumentation.captureRenderTime = true;
        instrumentation.captureInterFrameTime = true;
        


        engine.runRenderLoop(function(){
        
        scene.metadata.performance.text = "FPS: " + Math.round(1000/instrumentation.interFrameTimeCounter.current * 100) / 100 + "\n" + "Frame Time: " + Math.round(instrumentation.frameTimeCounter.current * 100) / 100 + "ms" + "\n" + "Render Time: " + Math.round(instrumentation.renderTimeCounter.current * 100) / 100 + "ms" + "\n" + "Interframe Time: " + Math.round(instrumentation.interFrameTimeCounter.current * 100) / 100 + "ms";
        


    
        //move all ships
        for(let i = 0; i < scene.metadata.ships.length; i++){
            let ship = scene.metadata.ships[i];
            
            
                //wasd controls (pressedKeys["key"])
                //adjust roll, pitch, yaw, make changes in local space
                let rotationInput = new BABYLON.Vector3(0,0,0);
                if(pressedKeys["q"]){
                    rotationInput.z += 0.25;
                }
                if(pressedKeys["e"]){
                    rotationInput.z -= 0.25;
                }
                if(pressedKeys["w"]){
                    rotationInput.x += 0.08;
                }
                if(pressedKeys["s"]){
                    rotationInput.x -= 0.08;
                }
                if(pressedKeys["d"]){
                    rotationInput.y += 0.05;
                }
                if(pressedKeys["a"]){
                    rotationInput.y -= 0.05;
                }
                //change thrust input (lerp)
                let throttleInput = 0;
                if(pressedKeys[" "]){
                    throttleInput = 1;
                }
                ship.controls.throttleInput = Math.floor(255*((ship.controls.throttleInput*0.85) + (throttleInput*0.15)))/255;
                
                //same for brakeinput
                let brakeInput = 0;
                if(pressedKeys["b"]){
                    brakeInput = 1;
                }
                ship.controls.brakeInput = (ship.controls.brakeInput*0.9) + (brakeInput*0.1);
                
                //lerp between old rotation input and new rotation input
                rotationInputLerp = BABYLON.Vector3.Lerp(ship.controls.rotationInput, rotationInput, 0.12);
                ship.controls.rotationInput = rotationInputLerp.clone();

            


                let rotationAmount = rotationInputLerp.length()/4;
                ship.mesh.rotate(rotationInputLerp.normalize(), rotationAmount, BABYLON.Space.LOCAL);
                



                //lerp between velocity vector and rotation vector, in both ways
                let angleOfAttack = Math.acos(BABYLON.Vector3.Dot(ship.mesh.forward.normalize(), ship.velocity.clone().normalize()));
                //if nan, set to 0
                if(isNaN(angleOfAttack)){
                    angleOfAttack = 0;
                }

                let rotationVel = ship.mesh.forward.scale(ship.velocity.length());
                
                //wing lift is maximized at 15째, but stalls at 25째
                let maxLiftAngle = 0.26;
                let stallAngle = 0.35;
                let stallSpeed = 0.4;
                
                //strength lerps from 0.1 to 1 (at maxLiftAngle) and then to 0.14 (at stallAngle)
                //use linear interpolation
                if(angleOfAttack < maxLiftAngle){
                    //scalar lerp 1
                    strength = 0.1 + (angleOfAttack/maxLiftAngle)*0.9;
                } else {
                    //scalar lerp 2
                    strength = 1 - ((angleOfAttack-maxLiftAngle)/(stallAngle-maxLiftAngle))*0.86;
                }
                strength = strength*0.7;


                if(angleOfAttack > stallAngle){
                    strength = 0.01;
                }
                //stall speed is 0.4
                if(ship.velocity.length() < stallSpeed){
                    strength *= ship.velocity.length()/stallSpeed;
                }
                strength *= 0.55;



                ship.velocity = BABYLON.Vector3.Lerp(ship.velocity, rotationVel, 0.2*strength);
                
                //get angle of attack
                //if that is high, rotate() ship.mesh to match velocity
                if(angleOfAttack > 0.06){
                    let axis = BABYLON.Vector3.Cross(ship.mesh.forward, ship.velocity.clone().normalize());
                    ship.mesh.rotate(axis, 0.000025, BABYLON.Space.WORLD);
                }
                
                //high angle of attack = high drag
                let drag = ((angleOfAttack**2)/3*ship.velocity.length()/5)*0.2;
                //vertical angle of attack = high drag


                //add brake input
                drag += ship.controls.brakeInput*0.006;

                if(ship.velocity.length() > 0.1){
                    ship.velocity = ship.velocity.scale(1-drag);
                }

                //apply gravity
                ship.velocity.y -= 0.002;
                

                
                //if stalled, thrust is reduced



                //couple particlesystem emission rate to throttle input
                ship.engineParticles.emitRate = ship.controls.throttleInput*120;
                //color is blue if speed vector length is less than 0.5, red if greater than 0.5
                if(ship.velocity.length() < 0.8){
                    ship.engineParticles.color1 = new BABYLON.Color4(0.2, 0.2, 1, 1);
                    ship.engineParticles.color2 = new BABYLON.Color4(0.2, 0.2, 1, 1);
                } else {
                    ship.engineParticles.color1 = new BABYLON.Color4(1, 0.2, 0.2, 1);
                    ship.engineParticles.color2 = new BABYLON.Color4(1, 0.2, 0.2, 1);
                }

                //manage start stop state
                if(ship.controls.throttleInput > 0.1 && !ship.started){
                    ship.started = true;
                    ship.engineParticles.start();
                } else if(ship.controls.throttleInput < 0.1 && ship.started){
                    ship.started = false;
                    ship.engineParticles.stop();
                }








                let thrust = 0.012;
                if(ship.velocity.length() < 0.8 && ship.velocity.length() > 0.1){
                    thrust *= 0.55;
                }
                ship.velocity = ship.velocity.add(ship.mesh.forward.scale(ship.controls.throttleInput*thrust));


                ship.mesh.moveWithCollisions(ship.velocity);

                //draw speed and angle of attack
                
            




            if(i==0){
            //point camera at ship using lookAt
            scene.activeCamera.setTarget(ship.position);
            
            //move camera behind ship, smoothly
            let cameraOffset = new BABYLON.Vector3(0, 2, -5.4);

            //if camera offset metadata not set, set it
            if(!scene.metadata.cameraOffset){
                scene.metadata.cameraOffset = cameraOffset;
            }
            //modify camera offset with arrow keys
            if(pressedKeys["ArrowUp"]){
                cameraOffset.z += 5;
                cameraOffset.y += 3;
            }
            if(pressedKeys["ArrowDown"]){
                cameraOffset.z += 5;
                cameraOffset.y -= 3;
            }
            if(pressedKeys["ArrowLeft"]){
                cameraOffset.x -= 4;
                cameraOffset.y += 2;
            }
            if(pressedKeys["ArrowRight"]){
                cameraOffset.x += 4;
                cameraOffset.y += 2;
            }
            
            cameraOffset = BABYLON.Vector3.Lerp(scene.metadata.cameraOffset, cameraOffset, 0.08);
            
            scene.metadata.cameraOffset = cameraOffset.clone();


            cameraOffsetGlobal = BABYLON.Vector3.TransformCoordinates(cameraOffset, ship.mesh.getWorldMatrix());
            scene.activeCamera.position = BABYLON.Vector3.Lerp(scene.activeCamera.position, cameraOffsetGlobal, 0.3);
            
            //draw flight data
            let speed = ship.velocity.length();
            let angleOfAttack = Math.acos(BABYLON.Vector3.Dot(ship.mesh.forward.normalize(), ship.velocity.clone().normalize()));
            //if nan, set to 0
            if(isNaN(angleOfAttack)){
                angleOfAttack = 0;
            }
            let angleOfAttackDegrees = angleOfAttack*180/Math.PI;
            let angleOfAttackDegreesRounded = Math.round(angleOfAttackDegrees*100)/100;
            let speedRounded = Math.round(speed*120*100)/100;
            let speedText = "Speed: " + speedRounded + " m/s";
            let angleOfAttackText = "Angle of Attack: " + angleOfAttackDegreesRounded + "째";
            let throttleInputText = "Throttle: " + Math.round(ship.controls.throttleInput*100) + "%";
            //draw text to scene.metadata.hud   
            scene.metadata.hud.text = speedText + "\n" + angleOfAttackText + "\n" + throttleInputText;
        
        
            //get coordinates and check map.get for collision
            //let mapHeight = 60*map.get(ship.position.x, ship.position.z);
            
            let mapHeight = 0;

            mapHeight = Math.max(mapHeight, 0);
            if(ship.position.y < mapHeight){
                ship.position.y = mapHeight;
                ship.velocity.y = 0;
                //apply strong drag
                ship.velocity = ship.velocity.scale(0.5);
                
            }
        
        
        
        
        
            }





        }

        //render call


        scene.render();
        });
        window.addEventListener('resize', function(){
            engine.resize();
        });

      




        
        //hide scrollbars
        document.body.style.overflow = 'hidden';
        //also hide cursor
        //document.body.style.cursor = 'none';
        //hide left side image gap
        document.body.style.margin = '0px';

        //loop background music "phasing_through.ogg"
        let bgm = new Audio("./Phasing_through.ogg");
        bgm.loop = true;
        //on keypress, play bgm
        document.addEventListener('keydown', function(){
            bgm.play();
        });        



    </script>
</html>