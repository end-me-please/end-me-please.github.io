<html>
    <head>
        <script src="./heightmap.js"></script>
        <script src="https://cdn.babylonjs.com/babylon.js"></script>
    </head>
    
    <body>

        <canvas id="noisemapTest" width="512" height="512"></canvas>








    </body>
    <script>
        let pressedKeys = {};
        let chunks = [];
        const chunkSize = 150;
        const mapScale = 1;
        const pathScale = 1;
        
        document.addEventListener('keydown', function(event){
            if(!event.key.startsWith('F')) event.preventDefault()
            else return;
            
            pressedKeys[event.key] = true;
            //if not a "function" key, prevent default action
        });
        document.addEventListener('keyup', function(event){
            if(!event.key.startsWith('F')) event.preventDefault()
            else return;
            pressedKeys[event.key] = false;
        });

        let canvas = document.getElementById("noisemapTest");
        //full screen canvas
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        let map = new NoiseMap(0.072);
        let engine = new BABYLON.Engine(canvas, true, {preserveDrawingBuffer: true, stencil: true});

        function setupScene() {
            let scene = new BABYLON.Scene(engine);
            let camera = new BABYLON.FreeCamera('camera1', new BABYLON.Vector3(0, 5, -10), scene);
            //camera.setTarget(BABYLON.Vector3.Zero());
            camera.attachControl(canvas, false);

            //directional light
            let light = new BABYLON.DirectionalLight("dir01", new BABYLON.Vector3(-0.3, -0.4, -1), scene);
            light.intensity = 1;
            //hemispheric light
            let light2 = new BABYLON.HemisphericLight("HemiLight", new BABYLON.Vector3(0, 1, 0), scene);
            light2.intensity = 0.3;

            //scene color to black
            scene.clearColor = new BABYLON.Color3(0, 0, 0);
            
            //generate chunks, from x=0 to x=300, 100 size
            for(let x = 0; x < 1200; x+=chunkSize){
                    chunks.push(generateChunk(scene,0,x*0.99));

            }
            



            return scene;
        }

        function generateChunk(scene,x,y){

            let mountains = BABYLON.MeshBuilder.CreateGroundFromHeightMap("largeGround", getMap(x,y), {width: chunkSize, height: chunkSize, subdivisions: 80, minHeight: 0, maxHeight: 30}, scene);
            //purple wireframe for mountains
            mountains.material = new BABYLON.StandardMaterial("mountainWireframe", scene);
            mountains.material.wireframe = true;
            mountains.material.diffuseColor = new BABYLON.Color3(0.5, 0, 0.5);
            mountains.material.specularColor = new BABYLON.Color3(0, 0.13, 0);

            mountains.material.alpha = 1;
            //move down
            mountains.position.y -= 7;
            //second mountains, for occlusion
            let mountains2 = BABYLON.MeshBuilder.CreateGroundFromHeightMap("largeGround", getMap(x,y), {width: chunkSize, height: chunkSize, subdivisions: 80, minHeight: 0, maxHeight: 30}, scene);
            //black/opaque for occlusion
            mountains2.material = new BABYLON.StandardMaterial("mountainBlack", scene);
            mountains2.material.wireframe = false;
            mountains2.material.diffuseColor = new BABYLON.Color3(0, 0, 0);
            mountains2.material.specularColor = new BABYLON.Color3(0, 0, 0);
            mountains2.material.alpha = 1;
            //move down
            mountains2.position.y -= 7;

            
            //add two ground planes- one wireframe, one black opaque to hide everything below
            let ground = BABYLON.MeshBuilder.CreateGround("ground", {width: chunkSize, height: chunkSize, subdivisions: 35}, scene);
            ground.material = new BABYLON.StandardMaterial("groundWireframe", scene);
            ground.material.wireframe = true;
            ground.material.diffuseColor = new BABYLON.Color3(0.3, 0.87, 0.2);
            ground.material.specularColor = new BABYLON.Color3(0, 0, 0);
            ground.material.alpha = 0.5;
            let ground2 = BABYLON.MeshBuilder.CreateGround("ground2", {width: chunkSize, height: chunkSize, subdivisions: 35}, scene);
            ground2.material = new BABYLON.StandardMaterial("groundBlack", scene);
            ground2.material.wireframe = false;
            ground2.material.diffuseColor = new BABYLON.Color3(0, 0, 0);
            ground2.material.specularColor = new BABYLON.Color3(0, 0, 0);
            ground2.material.alpha = 1;


            let boulderMaterial = new BABYLON.StandardMaterial("boulderMat", scene);
            boulderMaterial.diffuseColor = new BABYLON.Color3(0.1, 0.1, 0.5);
            boulderMaterial.specularColor = new BABYLON.Color3(0, 0, 0);
            boulderMaterial.emissiveColor = new BABYLON.Color3(0, 0, 0.1);
            boulderMaterial.alpha = 1;
            boulderMaterial.wireframe = true;
            
            let boulders = [];
            for(let i = 0; i < 8; i++) {
            //probe a random position to check if a boulder can be placed there
            //mountain value at the target should be below 7
            //placement should be at 7
            let x = Math.random() * chunkSize;
            let y = Math.random() * chunkSize;
            

            let z = 1;
            let target = mountains2.getHeightAtCoordinates(x, y);
            if(target < 0) {
                let boulder = BABYLON.MeshBuilder.CreateSphere("boulder", {diameter: 2, segments: 2}, scene);
                boulder.position.x = x;
                boulder.position.y = 0.5;
                boulder.position.z = y;
                boulder.material = boulderMaterial;
                boulders.push(boulder);
                

            }

            }



            //shift all meshes to offset
            mountains.position.x += x;
            mountains.position.z += y;
            mountains2.position.x += x;
            mountains2.position.z += y;
            ground.position.x += x;
            ground.position.z += y;
            ground2.position.x += x;
            ground2.position.z += y;
            
            //shift boulders
            for(let i = 0; i < boulders.length; i++) {
                boulders[i].position.x += x;
                boulders[i].position.z += y;
            }


            //generate a function that disposes of all these
            let data = {
                x: x,
                y: y,
                dispose: function(){
                    mountains.dispose();
                    mountains2.dispose();
                    ground.dispose();
                    ground2.dispose();
                    for(let i = 0; i < boulders.length; i++) {
                        boulders[i].dispose();
                    }
                }
            }

            return data;
        }





        let oldX = 0;
        let oldDiff = 0;
        var scene = setupScene();
        engine.runRenderLoop(function(){
        /*
        //read pressed keys, move cam
        let horizontal = 0;
        let vertical = 0;
        //rewrite with switch statement
        if(pressedKeys['a']) vertical += 1;
        if(pressedKeys['d']) vertical -= 1;
        if(pressedKeys['s']) horizontal -= 1;
        if(pressedKeys['w']) horizontal += 1;
        if(pressedKeys['q']) scene.activeCamera.position.y -= 0.1;
        if(pressedKeys['e']) scene.activeCamera.position.y += 0.1;
        let speed = 0.1;
        //if shift is pressed, move faster
        if(pressedKeys['Shift']) speed = 0.4;
        
        
        //adjust to camera rotation
        let cam = scene.activeCamera;
        let camRotation = cam.rotation.y;
        let camCos = Math.sin(camRotation);
        let camSin = Math.cos(camRotation);
        let adjustedHorizontal = horizontal * camCos - vertical * camSin;
        let adjustedVertical = horizontal * camSin + vertical * camCos;

        //move camera
        cam.position.x += adjustedHorizontal * speed;
        cam.position.z += adjustedVertical * speed;

        */


        //increment camera y


        //get path
        
        let cameraY = scene.activeCamera.position.z;
        let path = getPath((cameraY-50));

        //move camera to path
        scene.activeCamera.position.x = path*chunkSize/2;
        let diff = scene.activeCamera.position.x - oldX;
        oldX = scene.activeCamera.position.x;
        let diff2 = diff - oldDiff;
        oldDiff = diff;
        //adjust roll
        scene.activeCamera.rotation.z = -diff2*5;
        //adjust yaw
        scene.activeCamera.rotation.y = diff/3;


        //if camera is too far ahead, generate new chunks. read latest chunk, generate new chunk at x=latestChunk+chunkSize
        let latestChunk = chunks[chunks.length-1];
        //if less than 3 chunks ahead, generate new chunk
        if(latestChunk.y < scene.activeCamera.position.z + 300){
            //generate new chunk
            let newChunk = generateChunk(scene, 0, (latestChunk.y+chunkSize-5));
            chunks.push(newChunk);
            //dispose of old chunk
            chunks[0].dispose();
            chunks.shift();
        }
        scene.activeCamera.position.z += pressedKeys['w'] ? 3 : 2;
        //move all particle systems
        for(let i = 0; i < scene.particleSystems.length; i++){
            scene.particleSystems[i].worldOffset = scene.activeCamera.position.clone();
            scene.particleSystems[i].worldOffset.z += 40;
            scene.particleSystems[i].worldOffset.x += 13;
            scene.particleSystems[i].worldOffset.y = 19;
        }
        

        scene.render();
        });
        window.addEventListener('resize', function(){
            engine.resize();
        });


        function getMap(xoff, yoff){
            let width=chunkSize*mapScale;
            let height=chunkSize*mapScale;
            let heightmap = new ImageData(width, height);
            //fill heightmap with noise using the NoiseMap class instance (map)

            //generate a texture with a width and height of chunkSize * mapScale, filled with noise
            for(let x = 0; x < width; x++){
                for(let y = 0; y < height; y++){
                    //convert to fractional chunk coordinates
                    let fx = x / width;
                    let fy = y / height;
                    let offXf = xoff;
                    let offYf = yoff;
                    
                    //get noise value
                    let value = map.get(fx*chunkSize - offXf, fy*chunkSize - offYf);
                    //convert to 0-255
                    value = Math.floor(value * 255);
                    //value = 255;
                    //get path from fy+offYf
                    let path = getPath((fy*chunkSize)-(offYf));
                    let path2 = getPath2((fy*chunkSize)-(offYf));
                    let path3 = getPath3((fy*chunkSize)-(offYf));
                    let targetX = path*chunkSize/2+chunkSize/2;
                    let targetX2 = path2*chunkSize/2+chunkSize/2;
                    let targetX3 = path3*chunkSize/2+chunkSize/2;
                    let distance = Math.abs(targetX - (fx*chunkSize - offXf));
                    let distance2 = Math.abs(targetX2 - (fx*chunkSize - offXf));
                    let distance3 = Math.abs(targetX3 - (fx*chunkSize - offXf));
                    //compare them
                    distance = Math.min(distance, distance2, distance3);
                    


                    //if distance is less than 10, set value to 0
                    if(distance < chunkSize/12){
                        value *= distance/(chunkSize/12);
                    }
                    if(distance < 25){
                        value *= 0.8;
                    }
                    if(distance < 15){
                        value *= 0.6;
                    }

                    //if less than chunkSize/24, set value to 0

                    if(distance < chunkSize/24){
                        //cap value to 25 max
                        value = 0;
                    } 
                    
                    let biome = 0.25+(Math.sin(yoff/2000)*0.5)+0.85;
                    value *= biome;

                    
                    let cell = (x + y * width) * 4;
                    heightmap.data[cell] = value;
                    heightmap.data[cell+1] = value;
                    heightmap.data[cell+2] = value;
                    heightmap.data[cell+3] = 255;
                }
            }
            



            //append new canvas to body
            let canv = document.createElement('canvas');
            canv.width = heightmap.width;
            canv.height = heightmap.height;
            //draw heightmap to canvas
            let ctx = canv.getContext('2d');
            ctx.putImageData(heightmap, 0, 0);
            let displacementMap = canv.toDataURL();
            return displacementMap;
        }
        
        function getPath(y){
            return (Math.sin((y/chunkSize)/(1*pathScale))*Math.sin((y/chunkSize)/(3*pathScale))) * 0.65;

        }
        function getPath2(y){
            return (Math.sin((y/chunkSize)/(0.5*pathScale))*Math.sin((y/chunkSize)/(5*pathScale)));
        }
        function getPath3(y){
            return (Math.sin((y/chunkSize)/(7*pathScale))*Math.sin((y/chunkSize)/(2*pathScale)))*4;
        }
        //hide scrollbars
        document.body.style.overflow = 'hidden';
        //also hide cursor
        document.body.style.cursor = 'none';
        //hide left side image gap
        document.body.style.margin = '0px';



    </script>
</html>