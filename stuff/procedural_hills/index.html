<html>
    <head>
        <script src="./heightmap.js"></script>
        <script src="https://cdn.babylonjs.com/babylon.js"></script>
    </head>
    
    <body>

        <canvas id="noisemapTest" width="512" height="512"></canvas>








    </body>
    <script>
        let pressedKeys = {};
        let chunks = [];
        const chunkSize = 90;
        const mapScale = 5;
        const pathScale = 1;

        document.addEventListener('keydown', function(event){
            if(!event.key.startsWith('F')) event.preventDefault()
            else return;
            
            pressedKeys[event.key] = true;
            //if not a "function" key, prevent default action
        });
        document.addEventListener('keyup', function(event){
            if(!event.key.startsWith('F')) event.preventDefault()
            else return;
            pressedKeys[event.key] = false;
        });

        let canvas = document.getElementById("noisemapTest");
        //full screen canvas
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        let map = new NoiseMap(0.072);
        let engine = new BABYLON.Engine(canvas, true, {preserveDrawingBuffer: true, stencil: true});

        function setupScene() {
            let scene = new BABYLON.Scene(engine);
            let camera = new BABYLON.FreeCamera('camera1', new BABYLON.Vector3(0, 5, -10), scene);
            camera.setTarget(BABYLON.Vector3.Zero());
            camera.attachControl(canvas, false);
            let light = new BABYLON.HemisphericLight('light1', new BABYLON.Vector3(0, 1, 0), scene);
            //scene color to black
            scene.clearColor = new BABYLON.Color3(0, 0, 0);
            
            //generate chunks, from x=0 to x=300, 100 size
            for(let x = 0; x < 900; x+=chunkSize){
                    chunks.push(generateChunk(scene,0,x));

            }


            return scene;
        }

        function generateChunk(scene,x,y){

            let mountains = BABYLON.MeshBuilder.CreateGroundFromHeightMap("largeGround", getMap(x,y), {width: chunkSize, height: chunkSize, subdivisions: 80, minHeight: 0, maxHeight: 30}, scene);
            //purple wireframe for mountains
            mountains.material = new BABYLON.StandardMaterial("mountainWireframe", scene);
            mountains.material.wireframe = true;
            mountains.material.diffuseColor = new BABYLON.Color3(0.5, 0, 0.5);
            mountains.material.specularColor = new BABYLON.Color3(0, 0, 0);

            mountains.material.alpha = 1;
            //move down
            mountains.position.y -= 7;
            //second mountains, for occlusion
            let mountains2 = BABYLON.MeshBuilder.CreateGroundFromHeightMap("largeGround", getMap(x,y), {width: chunkSize, height: chunkSize, subdivisions: 80, minHeight: 0, maxHeight: 30}, scene);
            //black/opaque for occlusion
            mountains2.material = new BABYLON.StandardMaterial("mountainBlack", scene);
            mountains2.material.wireframe = false;
            mountains2.material.diffuseColor = new BABYLON.Color3(0, 0, 0);
            mountains2.material.specularColor = new BABYLON.Color3(0, 0, 0);
            mountains2.material.alpha = 1;
            //move down
            mountains2.position.y -= 7;

            
            //add two ground planes- one wireframe, one black opaque to hide everything below
            let ground = BABYLON.MeshBuilder.CreateGround("ground", {width: chunkSize, height: chunkSize, subdivisions: 35}, scene);
            ground.material = new BABYLON.StandardMaterial("groundWireframe", scene);
            ground.material.wireframe = true;
            ground.material.diffuseColor = new BABYLON.Color3(0.3, 0.87, 0.2);
            ground.material.specularColor = new BABYLON.Color3(0, 0, 0);
            ground.material.alpha = 0.5;
            let ground2 = BABYLON.MeshBuilder.CreateGround("ground2", {width: chunkSize, height: chunkSize, subdivisions: 35}, scene);
            ground2.material = new BABYLON.StandardMaterial("groundBlack", scene);
            ground2.material.wireframe = false;
            ground2.material.diffuseColor = new BABYLON.Color3(0, 0, 0);
            ground2.material.specularColor = new BABYLON.Color3(0, 0, 0);
            ground2.material.alpha = 1;

            //shift all meshes to offset
            mountains.position.x += x;
            mountains.position.z += y;
            mountains2.position.x += x;
            mountains2.position.z += y;
            ground.position.x += x;
            ground.position.z += y;
            ground2.position.x += x;
            ground2.position.z += y;


            //generate a function that disposes of all these
            let data = {
                x: x,
                y: y,
                dispose: function(){
                    mountains.dispose();
                    mountains2.dispose();
                    ground.dispose();
                    ground2.dispose();
                }
            }

            return data;
        }





        let oldX = 0;
        let oldDiff = 0;
        var scene = setupScene();
        engine.runRenderLoop(function(){
        /*
        //read pressed keys, move cam
        let horizontal = 0;
        let vertical = 0;
        //rewrite with switch statement
        if(pressedKeys['a']) vertical += 1;
        if(pressedKeys['d']) vertical -= 1;
        if(pressedKeys['s']) horizontal -= 1;
        if(pressedKeys['w']) horizontal += 1;
        if(pressedKeys['q']) scene.activeCamera.position.y -= 0.1;
        if(pressedKeys['e']) scene.activeCamera.position.y += 0.1;
        let speed = 0.1;
        //if shift is pressed, move faster
        if(pressedKeys['Shift']) speed = 0.4;
        
        
        //adjust to camera rotation
        let cam = scene.activeCamera;
        let camRotation = cam.rotation.y;
        let camCos = Math.sin(camRotation);
        let camSin = Math.cos(camRotation);
        let adjustedHorizontal = horizontal * camCos - vertical * camSin;
        let adjustedVertical = horizontal * camSin + vertical * camCos;

        //move camera
        cam.position.x += adjustedHorizontal * speed;
        cam.position.z += adjustedVertical * speed;

        */


        //increment camera y
        scene.activeCamera.position.z += 2;
        scene.activeCamera.position.y = 9;
        //get path
        
        let cameraY = scene.activeCamera.position.z;
        let path = getPath((cameraY-20));

        //move camera to path
        scene.activeCamera.position.x = path*chunkSize/2;
        let diff = scene.activeCamera.position.x - oldX;
        oldX = scene.activeCamera.position.x;
        let diff2 = diff - oldDiff;
        oldDiff = diff;
        //adjust roll
        scene.activeCamera.rotation.z = -diff2*5;
        //adjust yaw
        scene.activeCamera.rotation.y = diff/3;


        //if camera is too far ahead, generate new chunks. read latest chunk, generate new chunk at x=latestChunk+chunkSize
        let latestChunk = chunks[chunks.length-1];
        //if less than 3 chunks ahead, generate new chunk
        if(latestChunk.y < scene.activeCamera.position.z + chunkSize*8){
            //generate new chunk
            let newChunk = generateChunk(scene, 0, latestChunk.y+chunkSize);
            chunks.push(newChunk);
            //dispose of old chunk
            chunks[0].dispose();
            chunks.shift();
        }


        scene.render();
        });
        window.addEventListener('resize', function(){
            engine.resize();
        });


        function getMap(xoff, yoff){
            let width=chunkSize*mapScale;
            let height=chunkSize*mapScale;
            let heightmap = new ImageData(width, height);
            //fill heightmap with noise using the NoiseMap class instance (map)

            //generate a texture with a width and height of chunkSize * mapScale, filled with noise
            for(let x = 0; x < width; x++){
                for(let y = 0; y < height; y++){
                    //convert to fractional chunk coordinates
                    let fx = x / width;
                    let fy = y / height;
                    let offXf = xoff;
                    let offYf = yoff;
                    
                    //get noise value
                    let value = map.get(fx*chunkSize - offXf, fy*chunkSize - offYf);
                    //convert to 0-255
                    value = Math.floor(value * 255);

                    //get path from fy+offYf
                    let path = getPath((fy*chunkSize)-(offYf));
                    let targetX = path*chunkSize/2+chunkSize/2;
                    let distance = Math.abs(targetX - (fx*chunkSize - offXf));

                    //if distance is less than 10, set value to 0
                    if(distance < chunkSize/4){
                        value *= distance/(chunkSize/4);
                    }
                    //if less than chunkSize/8, set value to 0
                    if(distance < chunkSize/16){
                        value = 0;
                    }


                    
                    let cell = (x + y * width) * 4;
                    heightmap.data[cell] = value;
                    heightmap.data[cell+1] = value;
                    heightmap.data[cell+2] = value;
                    heightmap.data[cell+3] = 255;
                }
            }
            



            //append new canvas to body
            let canv = document.createElement('canvas');
            canv.width = heightmap.width;
            canv.height = heightmap.height;
            //draw heightmap to canvas
            let ctx = canv.getContext('2d');
            ctx.putImageData(heightmap, 0, 0);
            let displacementMap = canv.toDataURL();
            return displacementMap;
        }
        
        function getPath(y){
            return (Math.sin((y/chunkSize)/(1*pathScale))*Math.sin((y/chunkSize)/(3*pathScale))) * 0.65;

        }
        
        //hide scrollbars
        document.body.style.overflow = 'hidden';
        //also hide cursor
        document.body.style.cursor = 'none';
        //hide left side image gap
        document.body.style.margin = '0px';



    </script>
</html>