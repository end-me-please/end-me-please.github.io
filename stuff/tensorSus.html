<html>
    <head>
        <title>Tensor Sus</title>
    </head>
    <body>
        <h1>Tensor Sus</h1>
        <h3>escape</h3>
        <p>move with WASD, don't let the impostor get you</p>
        <canvas id="canvas" width="800" height="600"></canvas>




        <!---<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@2.0.0/dist/tf.min.js"></script>--->
        
        <script>
            class Tile{
                constructor(x,y,type,world){
                    this.world = world;
                    this.x = x;
                    this.y = y;
                    this.type = parseInt(type);            
                }
                draw(ctx){
                    //color gray for type 0
                    if(this.type == 0){
                        ctx.fillStyle = "rgb(200,200,200)";
                    }
                    //color brown for type 1
                    if(this.type == 1){
                        ctx.fillStyle = "rgb(150,100,50)";
                    }
                    ctx.fillRect(this.x*this.world.tileSize,this.y*this.world.tileSize,this.world.tileSize,this.world.tileSize);
                }

            }
        class World{
            constructor(canvas,width,height){
                this.canvas = canvas;
                this.width = width;
                this.height = height;
                //tileSize depends on the size of the canvas
                this.tileSize = Math.floor(this.canvas.width/this.width);
                //initialize the world
                //generate a maze first
                let maze=genMaze(this.width,this.height);
                //convert the maze to tiles
                this.tiles = [];
                for(let i=0;i<this.width;i++){
                    for(let j=0;j<this.height;j++){
                        this.tiles.push(new Tile(i,j,maze[i][j],this));
                    }
                }
                this.players = [];
                this.impostors = [];
            }
            tick(){

            }
            draw(){
                let ctx = this.canvas.getContext("2d");
                ctx.clearRect(0,0,this.canvas.width,this.canvas.height);
                for(let i=0;i<this.tiles.length;i++){
                    this.tiles[i].draw(ctx);
                }
                for(let i=0;i<this.players.length;i++){
                    this.players[i].draw(ctx);
                }
                for(let i=0;i<this.impostors.length;i++){
                    this.impostors[i].draw(ctx);
                }
            }
        }     

        const world=new World(document.getElementById("canvas"),20,20);
        //animate loop
        function animate(){
            world.draw();
            requestAnimationFrame(animate);
        }



        //maze generation function, returns a 2d array of true/false values
        function genMaze(width,height){
            let maze = [];
            for(let i = 0; i < width; i++){
                maze[i] = [];
                for(let j = 0; j < height; j++){
                    maze[i][j] = true;
                }
            }
            let stack = [];
            let current = {x:Math.floor(Math.random()*width),y:Math.floor(Math.random()*height)};
            maze[current.x][current.y] = false;
            stack.push(current);
            while(stack.length > 0){
                let neighbors = [];
                if(current.x > 0 && maze[current.x-1][current.y]){
                    neighbors.push({x:current.x-1,y:current.y});
                }
                if(current.x < width-1 && maze[current.x+1][current.y]){
                    neighbors.push({x:current.x+1,y:current.y});
                }
                if(current.y > 0 && maze[current.x][current.y-1]){
                    neighbors.push({x:current.x,y:current.y-1});
                }
                if(current.y < height-1 && maze[current.x][current.y+1]){
                    neighbors.push({x:current.x,y:current.y+1});
                }
                if(neighbors.length > 0){
                    let next = neighbors[Math.floor(Math.random()*neighbors.length)];
                    maze[next.x][next.y] = false;
                    maze[current.x][current.y] = false;
                    stack.push(current);
                    current = next;
                }else{
                    current = stack.pop();
                }
            }
            return maze;
        }
        </script>
    </body>
</html>