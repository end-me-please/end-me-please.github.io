<html>
    <head></head>



    <body>
        <canvas id="canvas" width="600" height="600" style="border: 1px solid red; background-color: aliceblue;"></canvas>
        <br>
        <div>
            <label id="stats">Stats:</label>
        </div>
        <br>
        <canvas id="inspect" width="400" height="400" style="border: 1px solid black; background-color: aliceblue;"></canvas>
        <button id="mutate" onclick="sim.mutate(0.1)">Mutate</button>
        <button id="evolve" onclick="sim.evolve()">next generation</button>
        
        </br>
        </br>
        <button id="save" onclick="saveAllWeights()">save</button>
        <button id="load" onclick="loadAllWeights()">load</button>
    </body>




    <script>
        let canvas = document.getElementById("canvas");
        let ctx = canvas.getContext("2d");
        let inspectCanvas = document.getElementById("inspect");
        let inspectCtx = inspectCanvas.getContext("2d");

        class Simulation {
            constructor(numFish) {
                this.width = 600;
                this.height = 600;
                this.numFish = numFish;
                this.fishes = [];
                for (let i = 0; i < numFish; i++) {
                    this.fishes.push(new Fish(this,Math.random() * this.width, Math.random() * this.height));
                }
            }
            fishIntensities(fish,channels){
                let intensities = [];
                for (let i = 0; i < channels; i++) {
                    intensities[i]=0;
                }
                
                //consider fish around the wrap around
                for (let i = 0; i < this.fishes.length; i++) {
                    let otherFish = this.fishes[i];
                    if(otherFish == fish) continue;
                    let angle = Math.atan2(otherFish.y - fish.y, otherFish.x - fish.x) - fish.angle;
                    if(angle < 0) angle += 2 * Math.PI;
                    let channel = Math.floor(angle / (2 * Math.PI / channels));
                    if(channel >= channels) continue;
                    let distance = Math.sqrt((otherFish.x - fish.x) ** 2 + (otherFish.y - fish.y) ** 2);
                    if(otherFish.x < fish.x - this.width / 2) distance = Math.sqrt((otherFish.x + this.width - fish.x) ** 2 + (otherFish.y - fish.y) ** 2);
                    if(otherFish.x > fish.x + this.width / 2) distance = Math.sqrt((otherFish.x - this.width - fish.x) ** 2 + (otherFish.y - fish.y) ** 2);
                    if(otherFish.y < fish.y - this.height / 2) distance = Math.sqrt((otherFish.x - fish.x) ** 2 + (otherFish.y + this.height - fish.y) ** 2);
                    if(otherFish.y > fish.y + this.height / 2) distance = Math.sqrt((otherFish.x - fish.x) ** 2 + (otherFish.y - this.height - fish.y) ** 2);
                    intensities[channel] += 1 / distance;
                }
                
                //if(distance > 80) continue;

                if(intensities.length != channels) {console.log(intensities);};
                
                return intensities;
            }
            update(){
                for (let i = 0; i < this.fishes.length; i++) {
                    this.fishes[i].act();
                    //wrap around
                    if(this.fishes[i].x < -5) this.fishes[i].x += this.width;
                    if(this.fishes[i].x > this.width+5) this.fishes[i].x -= this.width;
                    if(this.fishes[i].y < -5) this.fishes[i].y += this.height;
                    if(this.fishes[i].y > this.height+5) this.fishes[i].y -= this.height;

                }
            }
            render(ctx){
                ctx.clearRect(0,0,this.width,this.height);
                for (let i = 0; i < this.fishes.length; i++) {
                    let fish = this.fishes[i];
                    ctx.fillStyle = fish.color;
                    ctx.beginPath();
                    ctx.arc(fish.x,fish.y,fish.size,0,2 * Math.PI);
                    ctx.fill();
                    //draw fish eye in direction it is facing
                    ctx.fillStyle = "white";
                    ctx.beginPath();
                    ctx.arc(fish.x + Math.cos(fish.angle) * (fish.size*0.6),fish.y + Math.sin(fish.angle) * (fish.size*0.6),fish.size/3,0,2 * Math.PI);
                    ctx.fill();

                    
                }
            }
            mutate(factor){
                for (let i = 0; i < this.fishes.length; i++) {
                    if(Math.random()>0.7)this.fishes[i].mutate();
                }
            }

            evolve(){
                //get the top 10% of fishes
                let sortedFishes = this.fishes.sort((a,b) => b.score - a.score);
                let topFishes = sortedFishes.slice(0,Math.floor(this.fishes.length / 5));
                let newFishes = [];
                //randomly match top fish and pair them to create numFish new fishes
                for (let i = 0; i < this.numFish; i++) {
                    let fish1 = topFishes[Math.floor(Math.random() * topFishes.length)];
                    let fish2 = topFishes[Math.floor(Math.random() * topFishes.length)];
                    newFishes.push(fish1.pair(fish2));
                }
                this.fishes = newFishes;
            }

        }

        

        class Fish {
            constructor(world,x,y){
                this.world = world;
                this.x = x;
                this.y = y;
                this.angle = Math.random() * 2 * Math.PI;
                this.speed = 5;
                this.turnSpeed = 0.1;
                this.size = 10;
                this.color = "rgb("+Math.floor(Math.random()*255)+","+Math.floor(Math.random()*255)+","+Math.floor(Math.random()*255)+")";
                this.score = 0;
                this.sensorDirections = 8;
                this.brain = new FishBrain();
            }
            act(){
                let intensities = this.world.fishIntensities(this,this.sensorDirections);
                let output = this.brain.think(intensities);
                this.angle += output[0] * this.turnSpeed;
                this.x += Math.cos(this.angle) * (this.speed*output[1]);
                this.y += Math.sin(this.angle) * (this.speed*output[1]);
                let minDistance = Infinity;
                for(let i = 0; i < this.world.fishes.length; i++) {
                    let otherFish = this.world.fishes[i];
                    if(otherFish == this) continue;
                    let distance = Math.sqrt((otherFish.x - this.x) ** 2 + (otherFish.y - this.y) ** 2);
                    if(distance < minDistance) minDistance = distance;
                }

                if(minDistance > 5 * this.size) {this.score -=5;}
                if(minDistance > 3.1 * this.size) {this.score +=4;}
                if (minDistance < 3 * this.size) {this.score -=10;}
                if (minDistance < 1*this.size) {this.score -=100;}

                //close proximity to wall is highly discouraged
                if(this.x < 5) this.score -= 80;
                if(this.x > this.world.width - 5) this.score -= 80;
                if(this.y < 5) this.score -= 80;
                if(this.y > this.world.height - 5) this.score -= 80;



            }
            pair(other){
                let child = new Fish(this.world,this.world.width*Math.random(),this.world.height*Math.random());
                //average color
                let color1 = this.color.match(/\d+/g).map(Number);
                let color2 = other.color.match(/\d+/g).map(Number);
                let childColor = "rgb(";
                for (let i = 0; i < color1.length; i++) {
                    childColor += Math.floor((color1[i] + color2[i]) / 2);
                    if(i < color1.length - 1) childColor += ",";
                }
                childColor += ")";
                child.color = childColor;

                child.brain = this.brain.pair(other.brain);
                if(Math.random() < 0.01) child.mutate();
                return child;
            }
            mutate(){
                //mutate color
                let color = this.color.match(/\d+/g).map(Number);
                for (let i = 0; i < color.length; i++) {
                    color[i] += Math.floor(Math.random() * 50 - 25);
                    if(color[i] < 0) color[i] = 0;
                    if(color[i] > 255) color[i] = 255;
                }
                let newColor = "rgb(";
                for (let i = 0; i < color.length; i++) {
                    newColor += color[i];
                    if(i < color.length - 1) newColor += ",";
                }
                newColor += ")";
                this.color = newColor;

                this.brain.mutate(0.2);

            }

        }

        class FishBrain {
            constructor() {
                this.inputSize = 8;
                this.outputSize = 2;
                this.layerShape = [this.inputSize, this.outputSize];
                //count total number of nodes
                
                //all values from previous layer are multiplied by weights of their connections and added to all values of the next layer
                this.weights = [];
                for (let i = 0; i < this.layerShape.length - 1; i++) {
                    this.weights.push([]);
                    for (let j = 0; j < this.layerShape[i]; j++) {
                        this.weights[i].push([]);
                        for (let k = 0; k < this.layerShape[i + 1]; k++) {
                            this.weights[i][j].push(Math.random() * 2 - 1);
                        }
                    }
                }
                this.biases = [];
                //no biases for input and output layer
                for (let i = 1; i < this.layerShape.length - 1; i++) {
                    this.biases.push([]);
                    for (let j = 0; j < this.layerShape[i]; j++) {
                        this.biases[i-1].push(Math.random() * 0.02 - 0.01);
                    }
                }

                
                this.lastValues = [];
            }
            mutate(factor){
                for (let i = 0; i < this.weights.length; i++) {
                    for (let j = 0; j < this.weights[i].length; j++) {
                        for (let k = 0; k < this.weights[i][j].length; k++) {
                            this.weights[i][j][k] += factor*(Math.random() * 2 - 1);
                            if(Math.random() < factor/10) this.weights[i][j][k] = (Math.random() * 2 - 1) * 0.5;
                        }
                    }
                }
                //bias mutation
                for (let i = 0; i < this.biases.length; i++) {
                    for (let j = 0; j < this.biases[i].length; j++) {
                        this.biases[i][j] += (factor/5)*(Math.random() * 2 - 1);
                        if(Math.random() < factor/10) this.biases[i][j] = (Math.random() * 2 - 1) * 0.02;
                    }
                }
            }
            pair (other) {
                let child = new FishBrain();
                for (let i = 0; i < this.weights.length; i++) {
                    for (let j = 0; j < this.weights[i].length; j++) {
                        for (let k = 0; k < this.weights[i][j].length; k++) {
                            child.weights[i][j][k] = Math.random() < 0.5 ? this.weights[i][j][k] : other.weights[i][j][k];
                            if(Math.random() < 0.3) {
                                child.weights[i][j][k] = (this.weights[i][j][k] + other.weights[i][j][k]) / 2;
                            }
                        }
                    }
                }
                
                for (let i = 0; i < this.biases.length; i++) {
                    for (let j = 0; j < this.biases[i].length; j++) {
                        child.biases[i][j] = Math.random() < 0.8 ? this.biases[i][j] : other.biases[i][j];
                        if(Math.random() < 0.3) {
                            child.biases[i][j] = (this.biases[i][j] + other.biases[i][j]) / 2;
                        }
                    }
                }

                return child;
            }
            think (input) {
                if(input.length != this.inputSize) throw new Error("size does not match input size: "+ input.length);

                let values = [];
                for (let i = 0; i < this.layerShape.length; i++) {
                    values.push(Array(this.layerShape[i]).fill(0));
                }
                values[0] = input;
                for (let i = 0; i < this.layerShape.length - 1; i++) {
                    for (let j = 0; j < this.layerShape[i]; j++) {
                        for (let k = 0; k < this.layerShape[i + 1]; k++) {
                            //weight array is of shape [layer][node][next node]
                            let weightedValue = values[i][j] * this.weights[i][j][k];
                            let bias = (i==0||i==this.layerShape.length-1)?0:this.biases[i-1][j];
                            values[i + 1][k] += activation(weightedValue + bias);
                        }
                    }
                }
                this.lastValues = values;
                return values[values.length - 1];
            }

            draw(ctx) {
                let height = ctx.canvas.height;
                let width = ctx.canvas.width;
                ctx.clearRect(0,0,width,height);
                let circleRadius = 10;

                //distribute nodes around layers of circles, output layer being in the center
                let centerX = width / 2;
                let centerY = height / 2;
                let outerRadius = width / 2 - circleRadius;
               //start with outermost layer, the input layer

                let layerX = [];
                let layerY = [];
                for (let i = 0; i < this.layerShape.length; i++) {
                    layerX.push([]);
                    layerY.push([]);
                    for (let j = 0; j < this.layerShape[i]; j++) {
                        let angle = j / this.layerShape[i] * 2 * Math.PI;
                        layerX[i].push(centerX + Math.cos(angle) * outerRadius * (i+1) / this.layerShape.length);
                        layerY[i].push(centerY + Math.sin(angle) * outerRadius * (i+1) / this.layerShape.length);
                    }
                }

                //draw connections
                for (let i = 0; i < this.layerShape.length - 1; i++) {
                    for (let j = 0; j < this.layerShape[i]; j++) {
                        for (let k = 0; k < this.layerShape[i + 1]; k++) {
                            ctx.strokeStyle = this.weights[i][j][k] > 0 ? "green" : "red";
                            ctx.lineWidth = Math.abs(this.weights[i][j][k]) * 5;
                            ctx.beginPath();
                            ctx.moveTo(layerX[i][j],layerY[i][j]);
                            ctx.lineTo(layerX[i+1][k],layerY[i+1][k]);
                            ctx.stroke();
                        }
                    }
                }

                //draw nodes
                for (let i = 0; i < this.layerShape.length; i++) {
                    for (let j = 0; j < this.layerShape[i]; j++) {
                        ctx.fillStyle = "black";
                        ctx.beginPath();
                        ctx.arc(layerX[i][j],layerY[i][j],circleRadius,0,2 * Math.PI);
                        ctx.fill();

                    }
                }

            
            }
        }

        let sim = new Simulation(60);
        let inspectedFish = 0;
        sim.update();
        function loop(){
            try {
            sim.render(ctx);
            sim.fishes[inspectedFish].brain.draw(inspectCtx);
            //draw rectangle around observed fish
            ctx.strokeStyle = "red";
            ctx.beginPath();
            ctx.rect(sim.fishes[inspectedFish].x - sim.fishes[inspectedFish].size, sim.fishes[inspectedFish].y - sim.fishes[inspectedFish].size, sim.fishes[inspectedFish].size * 2, sim.fishes[inspectedFish].size * 2);
            ctx.stroke();
            //on the inspect canvas bottom right, print the fish's score
            inspectCtx.fillStyle = "black";
            inspectCtx.font = "15px Arial";
            inspectCtx.fillText("fitness: "+sim.fishes[inspectedFish].score, inspectCanvas.width*0.76, inspectCanvas.height*0.95);

            let highScore = 0;
            let lowScore = Infinity;
            let avgScore = 0;
            for (let i = 0; i < sim.fishes.length; i++) {
                avgScore += sim.fishes[i].score;
                if(sim.fishes[i].score > highScore) highScore = sim.fishes[i].score;
                if(sim.fishes[i].score < lowScore) lowScore = sim.fishes[i].score;
            }
            avgScore /= sim.fishes.length;
            
            document.getElementById("stats").innerHTML = "high score: "+highScore.toPrecision(3)+"<br>low score: "+lowScore.toPrecision(3)+"<br>avg score: "+avgScore.toPrecision(3);

            } catch (error) {
                console.log(error);
            }
            requestAnimationFrame(loop);
        }
        loop();

        setInterval(() => {
            sim.update();
        }, 6);
    
        canvas.addEventListener("click", e => {
            let rect = canvas.getBoundingClientRect();
            let x = e.clientX - rect.left;
            let y = e.clientY - rect.top;
            for (let i = 0; i < sim.fishes.length; i++) {
                let fish = sim.fishes[i];
                if(x > fish.x - fish.size && x < fish.x + fish.size && y > fish.y - fish.size && y < fish.y + fish.size) {
                    inspectedFish = i;
                    break;
                }
            }
        });

        function activation(x) {
            return (Math.tanh(x));
        }



        function saveAllWeights() {
            let weights = [];
            for (let i = 0; i < sim.fishes.length; i++) {
                weights.push(sim.fishes[i].brain.weights);
            }
            localStorage.setItem("weights",JSON.stringify(weights));
        }
        function loadAllWeights() {
            let weights = JSON.parse(localStorage.getItem("weights"));
            for (let i = 0; i < sim.fishes.length; i++) {
                sim.fishes[i].brain.weights = weights[i];
            }
        }


    </script>
</html>