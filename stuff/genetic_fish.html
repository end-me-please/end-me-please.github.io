<html>
    <head></head>



    <body>
        <canvas id="canvas" width="600" height="600" style="border: 1px solid red; background-color: aliceblue;"></canvas>
        <br>
        <canvas id="inspect" width="400" height="400" style="border: 1px solid black; background-color: aliceblue;"></canvas>
        <button id="mutate" onclick="sim.mutate(0.1)">Mutate</button>
        <button id="evolve" onclick="sim.evolve()">next generation</button>
        
        </br>
        </br>
        <button id="save" onclick="saveAllWeights()">save</button>
        <button id="load" onclick="loadAllWeights()">load</button>
    </body>




    <script>
        let canvas = document.getElementById("canvas");
        let ctx = canvas.getContext("2d");
        let inspectCanvas = document.getElementById("inspect");
        let inspectCtx = inspectCanvas.getContext("2d");

        class Simulation {
            constructor(numFish) {
                this.width = 600;
                this.height = 600;
                this.numFish = numFish;
                this.fishes = [];
                for (let i = 0; i < numFish; i++) {
                    this.fishes.push(new Fish(this,Math.random() * this.width, Math.random() * this.height));
                }
            }
            fishIntensities(fish,channels){
                let intensities = [];
                for (let i = 0; i < channels; i++) {
                    intensities[i]=0;
                }
                /*
                for (let i = 0; i < this.fishes.length; i++) {
                    let otherFish = this.fishes[i];
                    if(otherFish == fish) continue;
                    let angle = Math.atan2(otherFish.y - fish.y, otherFish.x - fish.x) - fish.angle;
                    if(angle < 0) angle += 2 * Math.PI;
                    let channel = Math.floor(angle / (2 * Math.PI / channels));
                    if(channel >= channels) continue;
                    let distance = Math.sqrt((otherFish.x - fish.x) ** 2 + (otherFish.y - fish.y) ** 2);
                    intensities[channel] += 1 / distance;
                }
                */
                //consider fish around the wrap around
                for (let i = 0; i < this.fishes.length; i++) {
                    let otherFish = this.fishes[i];
                    if(otherFish == fish) continue;
                    let angle = Math.atan2(otherFish.y - fish.y, otherFish.x - fish.x) - fish.angle;
                    if(angle < 0) angle += 2 * Math.PI;
                    let channel = Math.floor(angle / (2 * Math.PI / channels));
                    if(channel >= channels) continue;
                    let distance = Math.sqrt((otherFish.x - fish.x) ** 2 + (otherFish.y - fish.y) ** 2);
                    if(otherFish.x < fish.x - this.width / 2) distance = Math.sqrt((otherFish.x + this.width - fish.x) ** 2 + (otherFish.y - fish.y) ** 2);
                    if(otherFish.x > fish.x + this.width / 2) distance = Math.sqrt((otherFish.x - this.width - fish.x) ** 2 + (otherFish.y - fish.y) ** 2);
                    if(otherFish.y < fish.y - this.height / 2) distance = Math.sqrt((otherFish.x - fish.x) ** 2 + (otherFish.y + this.height - fish.y) ** 2);
                    if(otherFish.y > fish.y + this.height / 2) distance = Math.sqrt((otherFish.x - fish.x) ** 2 + (otherFish.y - this.height - fish.y) ** 2);
                    intensities[channel] += 1 / distance;
                }
                
                //if(distance > 80) continue;

                if(intensities.length != channels) {console.log(intensities);};
                
                return intensities;
            }
            update(){
                for (let i = 0; i < this.fishes.length; i++) {
                    this.fishes[i].act();
                    //wrap around
                    if(this.fishes[i].x < -5) this.fishes[i].x += this.width;
                    if(this.fishes[i].x > this.width+5) this.fishes[i].x -= this.width;
                    if(this.fishes[i].y < -5) this.fishes[i].y += this.height;
                    if(this.fishes[i].y > this.height+5) this.fishes[i].y -= this.height;

                }
            }
            render(ctx){
                ctx.clearRect(0,0,this.width,this.height);
                for (let i = 0; i < this.fishes.length; i++) {
                    let fish = this.fishes[i];
                    ctx.fillStyle = fish.color;
                    ctx.beginPath();
                    ctx.arc(fish.x,fish.y,fish.size,0,2 * Math.PI);
                    ctx.fill();
                    //draw fish eye in direction it is facing
                    ctx.fillStyle = "white";
                    ctx.beginPath();
                    ctx.arc(fish.x + Math.cos(fish.angle) * (fish.size*0.6),fish.y + Math.sin(fish.angle) * (fish.size*0.6),fish.size/3,0,2 * Math.PI);
                    ctx.fill();

                    
                }
            }
            mutate(factor){
                for (let i = 0; i < this.fishes.length; i++) {
                    this.fishes[i].brain.mutate(factor);
                }
            }

            evolve(){
                //get the top 10% of fishes
                let sortedFishes = this.fishes.sort((a,b) => b.score - a.score);
                let topFishes = sortedFishes.slice(0,Math.floor(this.fishes.length / 10));
                let newFishes = [];
                //randomly match top fish and pair them to create numFish new fishes
                for (let i = 0; i < this.numFish; i++) {
                    let fish1 = topFishes[Math.floor(Math.random() * topFishes.length)];
                    let fish2 = topFishes[Math.floor(Math.random() * topFishes.length)];
                    newFishes.push(fish1.pair(fish2));
                }
                this.fishes = newFishes;
            }

        }


        class Fish {
            constructor(world,x,y){
                this.world = world;
                this.x = x;
                this.y = y;
                this.angle = Math.random() * 2 * Math.PI;
                this.speed = 8;
                this.turnSpeed = 0.1;
                this.size = 10;
                this.color = "black";
                this.score = 0;
                this.sensorDirections = 8;
                this.brain = new FishBrain();
            }
            act(){
                let intensities = this.world.fishIntensities(this,this.sensorDirections);
                let output = this.brain.think(intensities);
                this.angle += output[0] * this.turnSpeed;
                this.x += Math.cos(this.angle) * (this.speed*output[1]);
                this.y += Math.sin(this.angle) * (this.speed*output[1]);
                let minDistance = Infinity;
                for(let i = 0; i < this.world.fishes.length; i++) {
                    let otherFish = this.world.fishes[i];
                    if(otherFish == this) continue;
                    let distance = Math.sqrt((otherFish.x - this.x) ** 2 + (otherFish.y - this.y) ** 2);
                    if(distance < minDistance) minDistance = distance;
                }

                if(minDistance > 4 * this.size) {this.score -=3;}
                if (minDistance < 3 * this.size) {this.score -=4;}
                if (minDistance < 1*this.size) {this.score -=90;}

            }
            pair(other){
                let child = new Fish(this.world,this.world.width*Math.random(),this.world.height*Math.random());
                child.brain = this.brain.pair(other.brain);
                return child;
            }

        }

        class FishBrain {
            constructor() {
                this.inputSize = 8;
                this.outputSize = 2;
                this.layerShape = [this.inputSize, 6, this.outputSize];
                //count total number of nodes
                
                //all values from previous layer are multiplied by weights of their connections and added to all values of the next layer
                this.weights = [];
                for (let i = 0; i < this.layerShape.length - 1; i++) {
                    this.weights.push([]);
                    for (let j = 0; j < this.layerShape[i]; j++) {
                        this.weights[i].push([]);
                        for (let k = 0; k < this.layerShape[i + 1]; k++) {
                            this.weights[i][j].push(Math.random() * 2 - 1);
                        }
                    }
                }
                this.lastValues = [];
            }
            mutate(factor){
                for (let i = 0; i < this.weights.length; i++) {
                    for (let j = 0; j < this.weights[i].length; j++) {
                        for (let k = 0; k < this.weights[i][j].length; k++) {
                            this.weights[i][j][k] += factor*(Math.random() * 2 - 1);
                        }
                    }
                }
            }
            pair (other) {
                let child = new FishBrain();
                for (let i = 0; i < this.weights.length; i++) {
                    for (let j = 0; j < this.weights[i].length; j++) {
                        for (let k = 0; k < this.weights[i][j].length; k++) {
                            child.weights[i][j][k] = Math.random() < 0.5 ? this.weights[i][j][k] : other.weights[i][j][k];
                        }
                    }
                }
                return child;
            }
            think (input) {
                if(input.length != this.inputSize) throw new Error("size does not match input size: "+ input.length);

                let values = [];
                for (let i = 0; i < this.layerShape.length; i++) {
                    values.push(Array(this.layerShape[i]).fill(0));
                }
                values[0] = input;
                for (let i = 0; i < this.layerShape.length - 1; i++) {
                    for (let j = 0; j < this.layerShape[i]; j++) {
                        for (let k = 0; k < this.layerShape[i + 1]; k++) {
                            //weight array is of shape [layer][node][next node]
                            values[i + 1][k] += activation(values[i][j] * this.weights[i][j][k]);
                        }
                    }
                }
                this.lastValues = values;
                return values[values.length - 1];
            }

            draw(ctx) {
                let height = ctx.canvas.height;
                let width = ctx.canvas.width;
                ctx.clearRect(0,0,width,height);
                let circleRadius = 10;

                
                for(let layer = 0; layer < this.layerShape.length; layer++) {
                for(let i = 0; i < this.layerShape[layer]; i++){
                    let drawX = 0;
                    let drawY = 0;
                    if(layer > 0){
                    drawX = circleRadius+layer*width/this.layerShape.length;
                    drawY = circleRadius+i * height / this.layerShape[layer];
                    }
                    ctx.fillStyle = "green";
                    ctx.beginPath();
                    ctx.arc(drawX,drawY, circleRadius, 0, 2 * Math.PI);
                    ctx.fill();
                    let lastNodeValue = this.lastValues[layer][i];
                    //
                    ctx.fillStyle = lastNodeValue > 0 ? "red" : "blue";
                    ctx.beginPath();
                    ctx.arc(drawX,drawY, Math.abs(circleRadius * lastNodeValue * 4), 0, 2 * Math.PI);
                    ctx.fill();




                    ctx.strokeStyle = "black";
                    for(let j = 0; j < this.layerShape[layer + 1]; j++){
                        let nextDrawX = circleRadius+(layer+1)*width/this.layerShape.length;
                        let nextDrawY = circleRadius+j * height / this.layerShape[layer + 1];
                        ctx.beginPath();
                        ctx.moveTo(drawX,drawY);
                        ctx.lineWidth = this.weights[layer][i][j] * 1;
                        ctx.lineTo(nextDrawX,nextDrawY);
                        ctx.stroke();
                    }
                    

                }
            }


            }


        }

        let sim = new Simulation(35);
        let inspectedFish = 0;
        function loop(){
            sim.update();
            sim.render(ctx);
            sim.fishes[inspectedFish].brain.draw(inspectCtx);
            //draw rectangle around observed fish
            ctx.strokeStyle = "red";
            ctx.beginPath();
            ctx.rect(sim.fishes[inspectedFish].x - sim.fishes[inspectedFish].size, sim.fishes[inspectedFish].y - sim.fishes[inspectedFish].size, sim.fishes[inspectedFish].size * 2, sim.fishes[inspectedFish].size * 2);
            ctx.stroke();
            //on the inspect canvas bottom right, print the fish's score
            inspectCtx.fillStyle = "black";
            inspectCtx.font = "15px Arial";
            inspectCtx.fillText("fitness: "+sim.fishes[inspectedFish].score, inspectCanvas.width*0.76, inspectCanvas.height*0.95);
            requestAnimationFrame(loop);

        }
        loop();

    
        canvas.addEventListener("click", e => {
            let rect = canvas.getBoundingClientRect();
            let x = e.clientX - rect.left;
            let y = e.clientY - rect.top;
            for (let i = 0; i < sim.fishes.length; i++) {
                let fish = sim.fishes[i];
                if(x > fish.x - fish.size && x < fish.x + fish.size && y > fish.y - fish.size && y < fish.y + fish.size) {
                    inspectedFish = i;
                    break;
                }
            }
        });

        function activation(x) {
            return (Math.tanh(x));
        }



        function saveAllWeights() {
            let weights = [];
            for (let i = 0; i < sim.fishes.length; i++) {
                weights.push(sim.fishes[i].brain.weights);
            }
            localStorage.setItem("weights",JSON.stringify(weights));
        }
        function loadAllWeights() {
            let weights = JSON.parse(localStorage.getItem("weights"));
            for (let i = 0; i < sim.fishes.length; i++) {
                sim.fishes[i].brain.weights = weights[i];
            }
        }


    </script>
</html>