<html>
    <head>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/gpu.js/1.0.2/gpu.min.js" integrity="sha512-cr2nuynSuSV6MGtWlympE0qd1g1TKBuEhv9lcfbW8HrE9UbPPc8zMwcje1fb9w2kzxqRnsizh6c+YbE6Ab7wpg==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
        <script src="./matrix.js"></script>
        <script src="./fishbrainClassic.js"></script>
        <script src="./main.js"></script>
    </head>



    <body>
        <canvas id="canvas" width="800" height="800" style="border: 1px solid red; background-color: aliceblue;"></canvas>
        <canvas id="inspect" width="400" height="400" style="border: 1px solid black; background-color: aliceblue;"></canvas>
        <button id="extractOne" onclick="extractOne()">extract selected</button>
        <button id="importOne" onclick="importOne()">import single fish</button>
        <div>
            <label id="stats">Stats:</label>
        </div>
        <canvas id="performanceGraph" width="500" height="300" style="border: 1px solid black; background-color: aliceblue;"></canvas>
        <button id="mutate" onclick="sim.mutate(0.3)">Mutate</button>
        <button id="fastForward" onclick="fastForward(10)">fast forward 10 generations</button>
        
        </br>
        </br>
        <button id="save" onclick="saveAllWeights()">save all</button>
        <button id="load" onclick="loadAllWeights()">load all</button>

    </br>
    <button id="importClipboard" onclick="importClipboard()">import clipboard</button>
    <button id="exportClipboard" onclick="exportClipboard()">export clipboard</button>
    <br>
    <br>
    <br>
    <div id="changelog">
            <li>added changelog</li>
            <li>fish now spawn in circles</li>
            <li>proper fish serialization</li>
            <li>changed fastForward logic</li>
            <li>reduced mutation rate</li>
            <li>updated changelog</li>
            <li>"top fish of all times" will be kept permanently until a better one appears</li>
            <li>actual physics engine (net is only called once every 12 ticks, hopefully doesnt affect behaviour much, has massive performance boost)</li>
            <li>lots of physics stuff, objective now is staying stationary</li>
            <li>blue nodes for memory, carry their values to the next tick</li>
            <li>walls are bouncy, fine tuning parameters</li>
            <li>various things are broken</li>
            <li>removed crossover</li>
            <li>added crossover</li>
            <li>fish now have single antenna instead of eye array</li>
        </div>
    </body>




    <script>
    
        let autoUpdate = true;
        let performanceGraphCanvas = document.getElementById("performanceGraph");
        let performanceGraphCtx = performanceGraphCanvas.getContext("2d");
        let canvas = document.getElementById("canvas");
        let ctx = canvas.getContext("2d");
        let inspectCanvas = document.getElementById("inspect");
        let inspectCtx = inspectCanvas.getContext("2d");

        
        let sim = new Simulation(45);
        

        let inspectedFish = 0;
        sim.update();
        function loop(){
            try {
            sim.render(ctx);
            sim.fishes[inspectedFish].brain.draw(inspectCtx);
            //draw rectangle around observed fish
            ctx.strokeStyle = "red";
            ctx.beginPath();
            ctx.rect(sim.fishes[inspectedFish].x - sim.fishes[inspectedFish].size, sim.fishes[inspectedFish].y - sim.fishes[inspectedFish].size, sim.fishes[inspectedFish].size * 2, sim.fishes[inspectedFish].size * 2);
            ctx.stroke();
         

            //on the inspect canvas bottom right, print the fish's score
            inspectCtx.fillStyle = "black";
            inspectCtx.font = "15px Arial";
            inspectCtx.fillText("fitness: "+sim.fishes[inspectedFish].score, inspectCanvas.width*0.76, inspectCanvas.height*0.95);
            //print current velocity (calculate from vx and vy)
            inspectCtx.fillText("velocity: "+Math.sqrt(sim.fishes[inspectedFish].vx*sim.fishes[inspectedFish].vx+sim.fishes[inspectedFish].vy*sim.fishes[inspectedFish].vy).toFixed(3), inspectCanvas.width*0.76, inspectCanvas.height*0.9);
            let highScore = 0;
            let lowScore = Infinity;
            let avgScore = 0;
            for (let i = 0; i < sim.fishes.length; i++) {
                avgScore += sim.fishes[i].score;
                //log if nan
                if(isNaN(sim.fishes[i].score)) {throw sim.fishes[i]};


                if(sim.fishes[i].score > highScore) highScore = sim.fishes[i].score;
                if(sim.fishes[i].score < lowScore) lowScore = sim.fishes[i].score;
            }
            avgScore /= sim.fishes.length;
            
            //calculate mean score (not average)
            //sort and take middle value
            let sortedFishes = [...sim.fishes].sort((a,b) => a.score - b.score);
            let medianScore = sortedFishes[Math.floor(sortedFishes.length / 2)].score;
            //include generation number, round all numbers to 3 decimals
            //one per line
            document.getElementById("stats").innerHTML = "generation: "+sim.generation+"</br>high score: "+highScore.toFixed(3)+"</br>low score: "+lowScore.toFixed(3)+"</br>average score: "+avgScore.toFixed(3)+"</br>median score: "+medianScore.toFixed(3);

        } catch (error) {
                console.log(error);
            }
            requestAnimationFrame(loop);
        }
        loop();
        let tick = 0;

        setInterval(() => {
            sim.update();
            tick++;
        }, 5);
    
        canvas.addEventListener("click", e => {
            let rect = canvas.getBoundingClientRect();
            let x = e.clientX - rect.left;
            let y = e.clientY - rect.top;
            for (let i = 0; i < sim.fishes.length; i++) {
                let fish = sim.fishes[i];
                if(x > fish.x - fish.size && x < fish.x + fish.size && y > fish.y - fish.size && y < fish.y + fish.size) {
                    inspectedFish = i;
                    break;
                }
            }
        });

        function activation(x) {
            return Math.tanh(x);
        }


        function fastForward(generations) {
            autoUpdate = false;
            let generationTicks = 4000;
            for (let i = 0; i < generations; i++) {
                let startTime = Date.now();
                let ranTicks = sim.runGeneration(generationTicks);
                let endTime = Date.now();
                console.log("generation "+sim.generation + " finished, ticks: "+ranTicks+", time: "+(endTime-startTime)+"ms");
            }
            drawGraph(sim.fitnessHistory);
            autoUpdate = true;
        }









        function saveAllWeights() {
            //serialize simulation
            let serialized = sim.serialize();
            //save to local storage
            localStorage.setItem("simulation",JSON.stringify(serialized));

            

        
        }
        function loadAllWeights() {
            //load from local storage
            let serialized = JSON.parse(localStorage.getItem("simulation"));
            //deserialize simulation
            sim = Simulation.deserialize(serialized);
            //update graph
            drawGraph(sim.fitnessHistory);
        }

        function exportClipboard() {
            let data = sim.serialize();
            navigator.clipboard.writeText(JSON.stringify(data));
        }

        function importClipboard() {
            navigator.clipboard.readText().then(text => {
                let data = JSON.parse(text);
                sim = Simulation.deserialize(data);
            });
        }

        function extractOne() {
            let data = sim.fishes[inspectedFish].serialize();
            navigator.clipboard.writeText(JSON.stringify(data));
        }

        function importOne() {
            navigator.clipboard.readText().then(text => {
                let data = JSON.parse(text);
                sim.fishes[inspectedFish]=Fish.deserialize(sim,data);
            });
        }




        setInterval(() => {
            if(autoUpdate&&tick>3000){
            sim.evolve();
            console.log("generation "+sim.generation + " finished, ticks: "+tick);
            tick = 0;
            drawGraph(sim.fitnessHistory);




        }
        }, 20000);


        function drawGraph(data){
            //normalize data
            let max = 0;
            for (let i = 0; i < data.length; i++) {
                if(data[i] > max) max = data[i];
            }
            let normalizedData = [];
            for (let i = 0; i < data.length; i++) {
                normalizedData.push(data[i] / max);
            }
            //draw graph
            performanceGraphCtx.clearRect(0,0,performanceGraphCanvas.width,performanceGraphCanvas.height);
            performanceGraphCtx.strokeStyle = "rgba(0,0,0,0.5)";
            performanceGraphCtx.beginPath();
            performanceGraphCtx.moveTo(0,performanceGraphCanvas.height);
            for (let i = 0; i < normalizedData.length; i++) {
                performanceGraphCtx.lineTo(i / normalizedData.length * performanceGraphCanvas.width, performanceGraphCanvas.height - normalizedData[i] * performanceGraphCanvas.height);
            }
            performanceGraphCtx.stroke();
            //trendline
            let trendline = [];
            for (let i = 0; i < normalizedData.length; i++) {
                trendline.push(0);
            }
            for (let i = 0; i < normalizedData.length; i++) {
                for (let j = 0; j < 10; j++) {
                    if(i+j < normalizedData.length) trendline[i+j] += normalizedData[i];
                }
            }
            for (let i = 0; i < trendline.length; i++) {
                trendline[i] /= 10;
            }
            performanceGraphCtx.strokeStyle = "rgba(255,0,0,1)";
            performanceGraphCanvas.lineWidth = 4;
            performanceGraphCtx.beginPath();
            performanceGraphCtx.moveTo(0,performanceGraphCanvas.height);
            for (let i = 0; i < trendline.length; i++) {
                performanceGraphCtx.lineTo(i / trendline.length * performanceGraphCanvas.width, performanceGraphCanvas.height - trendline[i] * performanceGraphCanvas.height);
            }
            performanceGraphCtx.stroke();

        }




    </script>
</html>