<html>
    <head>
        <script src="dist/gpu-browser.js"></script>
    </head>
    <body>
        <label id="fps">69 fps</label>







        <script>

            let gpu = new GPU({mode: 'gpu'});

            const renderCellSize = 10;
            let width = Math.floor(window.innerWidth/renderCellSize);
            let height = Math.floor(window.innerHeight/renderCellSize);
            const gridWidth = 2500;
            const gridHeight = 1900;
            let fps = 0;

            let cgolUpdateKernel = gpu.createKernel(function (cells) {
                let x = this.thread.x;
                let y = this.thread.y;
                let cell = cells[y][x];
                let height = this.constants.height;
                let width = this.constants.width;

                let neighbors = cells[y][x-1] + cells[y][x+1] + cells[(y-1+height)%height][x] + cells[(y+1+height)%height][x] + cells[(y-1+height)%height][x-1] + cells[(y-1+height)%height][x+1] + cells[(y+1+height)%height][x-1] + cells[(y+1+height)%height][x+1];
                let nextState = 0;
                nextState = (neighbors==3)||(neighbors==2&&cell==1)?1:0;
                
                return nextState;

            }, {
                output: [gridWidth, gridHeight],
                pipeline: false,
                immutable: false,
                optimizeFloatMemory: true,
                constants: {
                    height: gridHeight,
                    width: gridWidth
                },

            });

            let cgolRenderKernel = gpu.createKernel(function (cells,x1,y1,x2,y2) {
                let x = this.thread.x;
                let y = this.thread.y;

                //scale to be in x1,y1,x2,y2
                x = Math.floor(x1 + (x2 - x1) * x / this.constants.width);
                y = Math.floor(y1 + (y2 - y1) * y / this.constants.height);

                
                let outOfBounds = x >= this.constants.gridWidth || y >= this.constants.gridHeight || x < 0 || y < 0;
                if(outOfBounds){
                    let chX = Math.floor(this.thread.x/25);
                    let chY = Math.floor(this.thread.y/25);
                    let checkerboard = (chX + chY) % 2;
                    this.color(checkerboard, 0, checkerboard, 1);
                    return 0;
                }

                let cell = cells[y][x];
                let color = cell * 255;
                this.color(color, color, color, 255);

            }, {
                output: [window.innerWidth, window.innerHeight],
                graphical: true,
                optimizeFloatMemory: true,
                immutable: false,
                constants: {
                    gridHeight: gridHeight,
                    gridWidth: gridWidth,
                    height: window.innerHeight,
                    width: window.innerWidth,
                }
            });



            let cells = [];
            for (let y = 0; y < gridHeight; y++) {
                cells[y] = [];
                for (let x = 0; x < gridWidth; x++) {
                    cells[y][x] = Math.round(Math.random()-0.44);
                }
            }

            let canvas = cgolRenderKernel.canvas;
            
            document.body.appendChild(canvas);


            let viewX = Math.floor(window.innerWidth / 2);
            let viewY = Math.floor(window.innerHeight / 2);
            let zoom = 2;
            let smoothZoom = zoom;
            let viewRect = [0,0,width,height];


            
            let current = cgolUpdateKernel(cells);
            function render() {
                updateViewRect();
                current = cgolUpdateKernel(current);
                cgolRenderKernel(current,viewRect[0],viewRect[1],viewRect[2],viewRect[3]);
                smoothZoom += (zoom - smoothZoom) / 10;
                fps++;
                requestAnimationFrame(render);
            };
            render();            
            setInterval(function(){
                document.getElementById("fps").innerHTML = fps + " fps";
                fps = 0;
                
            },1000);

            //allow manipulation of viewRect through pan and zoom
            let mouseDown = false;
            let lastMouseX = 0;
            let lastMouseY = 0;
            let lastViewRect = [0,0,width,height];
            

            function updateViewRect(){
                //determine the new viewRect based on viewX, viewY, and smoothZoom
                let viewWidth = width / smoothZoom;
                let viewHeight = height / smoothZoom;
                let x1 = viewX - viewWidth / 2;
                let y1 = viewY - viewHeight / 2;
                let x2 = viewX + viewWidth / 2;
                let y2 = viewY + viewHeight / 2;
                viewRect = [x1,y1,x2,y2];
            }
            //zoom and pan
            canvas.addEventListener('mousedown', function (e) {
                mouseDown = true;
                lastMouseX = e.clientX
                lastMouseY = e.clientY
            });
            canvas.addEventListener('mouseup', function (e) {
                mouseDown = false;
            });
            canvas.addEventListener('mousemove', function (e) {
                if (mouseDown) {
                    let dx = e.clientX - lastMouseX;
                    let dy = e.clientY - lastMouseY;
                    dx /=renderCellSize;
                    dy /=renderCellSize;
                    //determine a reasonable speed for panning
                    let speed = 1 / smoothZoom;
                    viewX -= dx * speed;
                    viewY += dy * speed;
                    //dont let the view go out of bounds
                    if (viewX < width / 2) viewX = width / 2;
                    if (viewY < height / 2) viewY = height / 2;
                    if (viewX > gridWidth - width / 2) viewX = gridWidth - width / 2;
                    if (viewY > gridHeight - height / 2) viewY = gridHeight - height / 2;
                    
                    lastMouseX = e.clientX
                    lastMouseY = e.clientY
                }
            });
            canvas.addEventListener('wheel', function (e) {
                e.preventDefault();
                let delta = e.deltaY;
                if (delta > 0) {
                    zoom *= 1.1;
                } else {
                    zoom /= 1.1;
                }
            });


            //hide scrollbars









        </script>


    </body>
</html>