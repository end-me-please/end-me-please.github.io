<html>
    <head>
        <script src="dist/gpu-browser.js"></script>
    </head>
    <body>
        <label id="fps">69 fps</label>







        <script>

            let gpu = new GPU({mode: 'gpu'});

            const renderCellSize = 10;
            let width = Math.floor(window.innerWidth/renderCellSize);
            let height = Math.floor(window.innerHeight/renderCellSize);
            const gridWidth = 1800;
            const gridHeight = 1800;
            let fps = 0;

            let cgolUpdateKernel = gpu.createKernel(function (cells) {
                let x = this.thread.x;
                let y = this.thread.y;
                let cell = cells[y][x];
                let height = this.constants.height;
                let width = this.constants.width;

                let neighbors = cells[y][x-1] + cells[y][x+1] + cells[(y-1+height)%height][x] + cells[(y+1+height)%height][x] + cells[(y-1+height)%height][x-1] + cells[(y-1+height)%height][x+1] + cells[(y+1+height)%height][x-1] + cells[(y+1+height)%height][x+1];
                let nextState = 0;
                nextState = (neighbors==3)||(neighbors==2&&cell==1)?1:0;
                return nextState;
            }, {
                output: [gridWidth, gridHeight],
                pipeline: false,
                immutable: false,
                optimizeFloatMemory: true,
                precision: 'single',
                tactic: 'speed',
                constants: {
                    height: gridHeight,
                    width: gridWidth
                },

            });

            let cgolRenderKernel = gpu.createKernel(function (cells,x1,y1,x2,y2) {
                let x = this.thread.x;
                let y = this.thread.y;

                x = Math.floor(x1 + (x2 - x1) * x / this.constants.width);
                y = Math.floor(y1 + (y2 - y1) * y / this.constants.height);

                
                let outOfBounds = x >= this.constants.gridWidth || y >= this.constants.gridHeight || x < 0 || y < 0;
                if(outOfBounds){
                    let chX = Math.floor(this.thread.x/25);
                    let chY = Math.floor(this.thread.y/25);
                    let checkerboard = (chX*chY)%2+Math.sin(chX+chY);

                    //add low amount of noise to checkerboard
                    checkerboard += Math.random()*0.1;

                    this.color(checkerboard, 0, checkerboard, 1);
                    return 0;
                }
                
                let cell = cells[y][x];
                let color = cell * 255;
                this.color(color, color, color, 255);

            }, {
                output: [window.innerWidth, window.innerHeight],
                graphical: true,
                optimizeFloatMemory: true,
                immutable: false,
                tactic: 'speed',
                constants: {
                    gridHeight: gridHeight,
                    gridWidth: gridWidth,
                    height: window.innerHeight,
                    width: window.innerWidth,
                }
            });



            let cells = [];
            for (let y = 0; y < gridHeight; y++) {
                cells[y] = [];
                for (let x = 0; x < gridWidth; x++) {
                    cells[y][x] = Math.round(Math.random()*0);
                }
            }

            let canvas = cgolRenderKernel.canvas;
            
            document.body.appendChild(canvas);


            let viewX = Math.floor(window.innerWidth / 2);
            let viewY = Math.floor(window.innerHeight / 2);
            let zoom = 2;
            let smoothZoom = zoom;
            let viewRect = [0,0,width,height];


            
            let current = cgolUpdateKernel(cells);
            function render() {
                updateViewRect();
                current = cgolUpdateKernel(current);
                cgolRenderKernel(current,viewRect[0],viewRect[1],viewRect[2],viewRect[3]);
                smoothZoom += (zoom - smoothZoom) / 10;
                fps++;
                requestAnimationFrame(render);
            };
            render();            
            setInterval(function(){
                document.getElementById("fps").innerHTML = fps + " fps";
                fps = 0;
                
            },1000);

            //allow manipulation of viewRect through pan and zoom
            let mouseDown = false;
            let lastMouseX = 0;
            let lastMouseY = 0;
            let lastViewRect = [0,0,width,height];
            

            function updateViewRect(){
                //determine the new viewRect based on viewX, viewY, and smoothZoom
                let viewWidth = width / smoothZoom;
                let viewHeight = height / smoothZoom;
                let x1 = viewX - viewWidth / 2;
                let y1 = viewY - viewHeight / 2;
                let x2 = viewX + viewWidth / 2;
                let y2 = viewY + viewHeight / 2;
                viewRect = [x1,y1,x2,y2];
            }
            //zoom and pan with right click
            canvas.addEventListener('mousedown', function (e) {
                //right click
                if (e.button == 2) {
                    mouseDown = true;
                    lastMouseX = e.clientX;
                    lastMouseY = e.clientY;
                    e.preventDefault();
                }
            });
            canvas.addEventListener('mouseup', function (e) {
                if(e.button == 2){
                    mouseDown = false;
                    e.preventDefault();
                }
            });
            canvas.addEventListener('mousemove', function (e) {
                if (mouseDown) {
                    let dx = e.clientX - lastMouseX;
                    let dy = e.clientY - lastMouseY;
                    dx /=renderCellSize;
                    dy /=renderCellSize;
                    //determine a reasonable speed for panning
                    let speed = 1 / smoothZoom;
                    viewX -= dx * speed;
                    viewY += dy * speed;
                    //dont let the view go out of bounds
                    if (viewX < width / 2) viewX = width / 2;
                    if (viewY < height / 2) viewY = height / 2;
                    if (viewX > gridWidth - width / 2) viewX = gridWidth - width / 2;
                    if (viewY > gridHeight - height / 2) viewY = gridHeight - height / 2;
                    
                    lastMouseX = e.clientX
                    lastMouseY = e.clientY
                }
            });
            canvas.addEventListener('wheel', function (e) {
                e.preventDefault();
                let delta = e.deltaY;
                if (delta > 0) {
                    zoom *= 1.1;
                } else {
                    zoom /= 1.1;
                }
            });


            //hide scrollbars

            //on g button press, spawn a glider
            canvas.addEventListener('click', function (e) {
                    e.preventDefault();
                    //get position of mouse in viewRect, mouse is lastMouseX, lastMouseY
                    let x = e.clientX / window.innerWidth * (viewRect[2] - viewRect[0]) + viewRect[0];
                    let y = e.clientY / window.innerHeight * (viewRect[1] - viewRect[3]) + viewRect[3];
                    //fix y
                    y = y;


                    //floor to nearest cell
                    x = Math.floor(x);
                    y = Math.floor(y);
                    //spawn glider in a random direction

                    let dir = Math.floor(Math.random() * 4);
                    if (dir == 0) {
                        current[y][x] = 1;
                        current[y + 1][x] = 1;
                        current[y + 2][x] = 1;
                        current[y + 2][x - 1] = 1;
                        current[y + 1][x - 2] = 1;
                    } else if (dir == 1) {
                        current[y][x] = 1;
                        current[y][x + 1] = 1;
                        current[y][x + 2] = 1;
                        current[y - 1][x + 2] = 1;
                        current[y - 2][x + 1] = 1;
                    } else if (dir == 2) {
                        current[y][x] = 1;
                        current[y - 1][x] = 1;
                        current[y - 2][x] = 1;
                        current[y - 2][x + 1] = 1;
                        current[y - 1][x + 2] = 1;
                    } else if (dir == 3) {
                        current[y][x] = 1;
                        current[y][x - 1] = 1;
                        current[y][x - 2] = 1;
                        current[y + 1][x - 2] = 1;
                        current[y + 2][x - 1] = 1;
                    }

                
            });


            //no right click menu
            canvas.addEventListener('contextmenu', function (e) {
                e.preventDefault();
            });

            //no double click to select text on the entire page
            canvas.addEventListener('dblclick', function (e) {
                e.preventDefault();
            });
            document.addEventListener('dblclick', function (e) {
                e.preventDefault();
            });


        </script>


    </body>
</html>