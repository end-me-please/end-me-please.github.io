<HTML>
    <head>
        <title>Snails!</title>
        <script src="proceduralsnails.js"></script>
        <script src="proceduralfruit.js"></script>
    </head>
    <body>
        <input type="range" id="speed" min="1" max="10" value="1">Speed</range>
        <canvas id="canvas" width="800" height="600"></canvas>

    </body>
    <script>
        let canvas = document.getElementById("canvas");
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        //remove margin and padding from the body
        document.body.style.margin = "0px";
        document.body.style.padding = "0px";
        //remove scrollbars
        document.body.style.overflow = "hidden";

        //move the speed slider on top of the canvas
        let speed = document.getElementById("speed");
        speed.style.position = "absolute";
        speed.style.top = "0px";
        speed.style.left = "0px";
        
        let trailCanvas = new OffscreenCanvas(canvas.width, canvas.height);
        let trailCtx = trailCanvas.getContext("2d");

        //clears the canvas
        let ctx = canvas.getContext("2d");
        ctx.clearRect(0, 0, canvas.width, canvas.height);


        let cursorX = 0;
        let cursorY = 0;
        let cursorDown = false;

        canvas.addEventListener("mousemove", function(event) {
            cursorX = event.clientX;
            cursorY = event.clientY;
        });
        canvas.addEventListener("mousedown", function(event) {
            cursorDown = true;

            //check position of cursor, if within a snail, add a crack
            for (let i = 0; i < snails.length; i++) {
                let dx = cursorX - snails[i].x;
                let dy = cursorY - snails[i].y;
                let distance = Math.sqrt(dx*dx + dy*dy);
                if (distance < snails[i].radius*2) {
                    snails[i].health--;
                }
            }

        });
        canvas.addEventListener("mouseup", function(event) {
            cursorDown = false;
        });

        let avgFrameTime = 5;
        


        class Snail extends RandomSnail {
            constructor(){
                super(Math.random()*32, Math.random()*256);
                super.radius = Math.random() * 9 + 5;
                this.x = Math.random() * canvas.width;
                this.y = Math.random() * canvas.height;

                this.speed = Math.random() * 2 + 1;
                this.angle = Math.random() * Math.PI * 2;

                this.drawX = this.x;
                this.drawY = this.y;
                this.drawAngle = this.angle;
                this.trail = [{x: this.x, y: this.y}];
                this.t = 0;
                this.health = 2;
                this.maxHealth = 2;
                this.dead=false;
            }
            update() {
                
                this.t++;

                if(this.health <= 0){
                    this.dead=true;
                }

                if(!this.dead){

                
                let vx = Math.cos(this.drawAngle) * this.speed;
                let vy = Math.sin(this.drawAngle) * this.speed;
                this.x += vx;
                this.y += vy;
                //lerp drawangle to angle, respecting wraparound
                let diff = this.angle - this.drawAngle;
                if (diff > Math.PI) diff -= Math.PI * 2;
                if (diff < -Math.PI) diff += Math.PI * 2;
                this.drawAngle += diff * 0.1;



                }

                //wrap around the screen, and push a wrap marker to the trail
                if (this.x < 0) {
                    this.x = canvas.width;

                    this.drawX = this.x;
                    this.drawY = this.y;
                    this.trail.push({x: this.x, y: this.y, wrap: true});
                }
                if (this.x > canvas.width) {
                    this.x = 0;

                    this.drawX = this.x;
                    this.drawY = this.y;
                    this.trail.push({x: this.x, y: this.y, wrap: true});
                }
                if (this.y < 0) {
                    this.y = canvas.height;

                    this.drawX = this.x;
                    this.drawY = this.y;
                    this.trail.push({x: this.x, y: this.y, wrap: true});
                }
                if (this.y > canvas.height) {
                    this.y = 0;

                    this.drawX = this.x;
                    this.drawY = this.y;
                    this.trail.push({x: this.x, y: this.y, wrap: true});
                }






                //lerp drawX and drawY to x and y
                this.drawX += (this.x - this.drawX) * 0.1;
                this.drawY += (this.y - this.drawY) * 0.1;

                //every 5 frames, add a new point to the trail
                if (this.t % (Math.pow(document.getElementById("speed").value,2)*3) == 0) this.trail.push({x: this.x, y: this.y, wrap: false});

                //if avg frame time is higher than 15ms, remove a point from the trail
                
                if (this.trail.length > 5) this.trail.shift();



                if(cursorDown){
                //get angle to cursor
                let dx = cursorX - this.x;
                let dy = cursorY - this.y;
                if(Math.sqrt(dx*dx + dy*dy) < 256){
                this.vx+=dx*0.01;
                this.vy+=dy*0.01;
                }
                }

                /*
                let cursorAngle = Math.atan2(dy, dx);
                //add 90 degrees to cursorAngle
                //lerp angle to cursorAngle
                let distance = Math.sqrt(dx*dx + dy*dy);
                this.lerpAngle(cursorAngle + Math.PI / 2, 1/(distance/this.radius+1));
                */



                //snap angle to 2PI
                if (this.angle > Math.PI * 2) this.angle -= Math.PI * 2; 
                if (this.angle < 0) this.angle += Math.PI * 2;


                //cap speed
                let speed = Math.sqrt(this.vx*this.vx + this.vy*this.vy);
                if (speed > 4) {
                    this.vx *= 4 / speed;
                    this.vy *= 4 / speed;
                }
                //lower limit on speed
                if (speed < 0.2) {
                    this.vx *= 0.2 / speed;
                    this.vy *= 0.2 / speed;
                }

                //set this.cracks to maxhealth-health
                this.cracks = this.maxHealth - this.health;
                //if health is 0, die



            }
            lerpAngle(angle, amount) {
                let diff = angle - this.angle;
                if (diff > Math.PI) diff -= Math.PI * 2;
                if (diff < -Math.PI) diff += Math.PI * 2;
                this.angle += diff * amount;
            }


            get vx() {
                return Math.cos(this.angle) * this.speed;
            }
            get vy() {
                return Math.sin(this.angle) * this.speed;
            }
            set vx(vx) {
                this.angle = Math.atan2(this.vy, vx);
                this.speed = Math.sqrt(vx*vx + this.vy*this.vy);
            }
            set vy(vy) {
                this.angle = Math.atan2(vy, this.vx);
                this.speed = Math.sqrt(this.vx*this.vx + vy*vy);
            }

            draw(ctx) {
                ctx.save();
                ctx.translate(this.drawX, this.drawY);
                ctx.rotate(this.drawAngle);
                super.draw(ctx);
                ctx.restore();

                //if within radius of wall, draw twice/slightly out of frame
                if (this.x < 2*this.radius) {
                    ctx.save();
                    ctx.translate(this.drawX + canvas.width, this.drawY);
                    ctx.rotate(this.drawAngle);
                    super.draw(ctx);
                    ctx.restore();
                }
                if (this.x > canvas.width - 2*this.radius) {
                    ctx.save();
                    ctx.translate(this.drawX - canvas.width, this.drawY);
                    ctx.rotate(this.drawAngle);
                    super.draw(ctx);
                    ctx.restore();
                }
                if (this.y < 2*this.radius) {
                    ctx.save();
                    ctx.translate(this.drawX, this.drawY + canvas.height);
                    ctx.rotate(this.drawAngle);
                    super.draw(ctx);
                    ctx.restore();
                }
                if (this.y > canvas.height - 2*this.radius) {
                    ctx.save();
                    ctx.translate(this.drawX, this.drawY - canvas.height);
                    ctx.rotate(this.drawAngle);
                    super.draw(ctx);
                    ctx.restore();
                }


            }
            drawTrail(ctx){
                ctx.beginPath();
                ctx.moveTo(this.trail[0].x, this.trail[0].y);
                for (let i = 1; i < this.trail.length; i++) {
                    if (this.trail[i].wrap) {
                        ctx.strokeStyle = this.footColor;
                        ctx.lineWidth = 1;
                        ctx.stroke();
                        ctx.beginPath();
                    }
                    ctx.lineTo(this.trail[i].x, this.trail[i].y);
                }
                ctx.strokeStyle = this.footColor;
                ctx.lineWidth = 1;
                //smudge the trail
                ctx.shadowBlur = 6;
                ctx.globalAlpha = 0.04;
                ctx.shadowColor = this.footColor;
                

                ctx.stroke();
            }

            collide(other){
                let dx = this.x - other.x;
                let dy = this.y - other.y;
                let distance = Math.sqrt(dx*dx + dy*dy);


                if (distance < this.radius + other.radius) {
                    this.vx *= -1;
                    this.vy *= -1;

                    
                    //move them apart
                    let angle = Math.atan2(dy, dx);
                    let overlap = this.radius + other.radius - distance;
                    this.x += overlap * Math.cos(angle);
                    this.y += overlap * Math.sin(angle);
                }

                if(distance < this.radius*25){
                    let oldvx = this.vx;
                    let oldvy = this.vy;
                    //if closer than 5, repel, if not, attract
                    if (distance < 7*this.radius) {
                        this.vx += dx * 0.0004;
                        this.vy += dy * 0.0004;
                    } else {
                        this.vx -= dx * 0.00001;
                        this.vy -= dy * 0.00001;
                    }
           
                    //lerp the speed with other.drawAngle
                    this.lerpAngle(other.drawAngle, 10/((distance/this.radius)+1));
                    
                }
             
            }

        }

        


        let snails = [];
        for (let i = 0; i < 350; i++) {
            snails.push(new Snail());
        }

        function frame() {
            let t = Date.now();
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            //put imagedata
            ctx.drawImage(trailCanvas, 0, 0);

            for (let i = 0; i < snails.length; i++) {
                snails[i].drawTrail(trailCtx);
            }

            for (let i = 0; i < snails.length; i++) {
                
                snails[i].draw(ctx);
            }
            

            
            for (let i = 0; i < Math.pow(speed.value,2); i++) {
                physicsFrame();
            }
            let frameTime = Date.now()-t;
            let newAvgFrameTime = (frameTime) * 0.05 + avgFrameTime * 0.95;
            avgFrameTime = newAvgFrameTime;
            window.requestAnimationFrame(frame);
            
        }

        function physicsFrame() {
            for (let i = 0; i < snails.length; i++) {
                snails[i].update();
                for (let j = i + 1; j < snails.length; j++) {
                    snails[i].collide(snails[j]);
                }
            }
        }






        setTimeout(function() {
            window.requestAnimationFrame(frame);
        }, 50);
        function randomColor() {
    let r = Math.floor(Math.random() * 255);
    let g = Math.floor(Math.random() * 255);
    let b = Math.floor(Math.random() *255);
    return "rgb(" + r + "," + g + "," + b + ")";
}
        


   </script>

</HTML>