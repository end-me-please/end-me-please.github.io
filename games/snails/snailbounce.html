<HTML>
    <head>
        <title>Snails!</title>
        <script src="proceduralsnails.js"></script>
    </head>
    <body>
        <input type="range" id="speed" min="1" max="10" value="1">Speed</range>
        <canvas id="canvas" width="800" height="600"></canvas>

    </body>
    <script>
        let canvas = document.getElementById("canvas");
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        //remove margin and padding from the body
        document.body.style.margin = "0px";
        document.body.style.padding = "0px";
        //remove scrollbars
        document.body.style.overflow = "hidden";

        //move the speed slider on top of the canvas
        let speed = document.getElementById("speed");
        speed.style.position = "absolute";
        speed.style.top = "0px";
        speed.style.left = "0px";
        
        //clears the canvas
        let ctx = canvas.getContext("2d");
        ctx.clearRect(0, 0, canvas.width, canvas.height);


        let cursorX = 0;
        let cursorY = 0;
        let cursorDown = false;
        canvas.addEventListener("mousemove", function(event) {
            cursorX = event.clientX;
            cursorY = event.clientY;
        });



        class Snail extends SnailGen {
            constructor(){
                super(randomColor(), randomColor(), Math.random()*20+3, randomColor(), Math.random()*32);
                super.radius = Math.random() * 10 + 10;
                this.x = Math.random() * canvas.width;
                this.y = Math.random() * canvas.height;

                this.speed = Math.random() * 2 + 1;
                this.angle = Math.random() * Math.PI * 2;

                this.drawX = this.x;
                this.drawY = this.y;
                this.drawAngle = this.angle;
                this.trail = [{x: this.x, y: this.y}];
                this.t = 0;

            }
            update() {
                this.t++;
                let vx = Math.cos(this.angle) * this.speed;
                let vy = Math.sin(this.angle) * this.speed;
                this.x += vx;
                this.y += vy;

                if (this.x < 0 || this.x > canvas.width) {
                    //angle of incidence = angle of reflection
                    this.angle = Math.atan2(vy, -vx);

                    this.x = Math.max(0, Math.min(canvas.width, this.x));
                }
                if (this.y < 0 || this.y > canvas.height) {
                    this.angle = Math.atan2(-vy, vx);
                    this.y = Math.max(0, Math.min(canvas.height, this.y));
                }



                //lerp drawX and drawY to x and y
                this.drawX += (this.x - this.drawX) * 0.1;
                this.drawY += (this.y - this.drawY) * 0.1;
                this.drawAngle += (this.angle - this.drawAngle) * 0.035;

                //every 5 frames, add a new point to the trail
                if (this.t % (Math.pow(document.getElementById("speed").value,2)*5) == 0) this.trail.push({x: this.x, y: this.y});

                //if trail longer than 500 points, remove the first point
                if (this.trail.length > 2000) this.trail.shift();


                //get angle to cursor
                let dx = cursorX - this.x;
                let dy = cursorY - this.y;
                let angleToCursor = Math.atan2(dy, dx);
                //slowly lerp towards cursor
                //get vx and vy from angle
                let vxToCursor = Math.cos(angleToCursor) * this.speed;
                let vyToCursor = Math.sin(angleToCursor) * this.speed;
                //refresh vx and vy from angle
                vx = Math.cos(this.angle) * this.speed;
                vy = Math.sin(this.angle) * this.speed;
                //lerp vx and vy to vxToCursor and vyToCursor
                vx += (vxToCursor - vx) * 0.01;
                vy += (vyToCursor - vy) * 0.01;
                //refresh angle from vx and vy
                this.angle = Math.atan2(vy, vx);



                //snap angle to 2PI
                this.angle = (this.angle + Math.PI * 2) % (Math.PI * 2);

            }
            draw(ctx) {
                ctx.save();
                ctx.translate(this.drawX, this.drawY);
                ctx.rotate(this.drawAngle);
                super.draw(ctx);
                ctx.restore();
            }
            drawTrail(ctx){
                ctx.beginPath();
                ctx.moveTo(this.trail[0].x, this.trail[0].y);
                for (let i = 1; i < this.trail.length; i++) {
                    ctx.lineTo(this.trail[i].x, this.trail[i].y);
                }
                ctx.strokeStyle = this.footColor;
                ctx.lineWidth = 1;
                ctx.stroke();
            }

            collide(other){
                let dx = this.x - other.x;
                let dy = this.y - other.y;
                let distance = Math.sqrt(dx*dx + dy*dy);


                if (distance < this.radius + other.radius) {
                    this.vx *= -1;
                    this.vy *= -1;

                    
                    //move them apart
                    let angle = Math.atan2(dy, dx);
                    let overlap = this.radius + other.radius - distance;
                    this.x += overlap * Math.cos(angle);
                    this.y += overlap * Math.sin(angle);
                }

                if(distance < this.radius*16){
                    let oldvx = this.vx;
                    let oldvy = this.vy;
                    //if closer than 5, repel, if not, attract
                    if (distance < 8*this.radius) {
                        this.vx += dx * 0.015;
                        this.vy += dy * 0.015;
                    } else {
                        this.vx -= dx * 0.001;
                        this.vy -= dy * 0.001;
                    }
                    //cap the speed
                    let speed = Math.sqrt(this.vx*this.vx + this.vy*this.vy);
                    if (speed > 5) {
                        this.vx *= 5 / speed;
                        this.vy *= 5 / speed;
                    }
                    //lerp the speed with other.angle
                    this.angle += (other.angle - this.angle) * 0.1/distance;

                }
             
            }

        }

        


        let snails = [];
        for (let i = 0; i < 100; i++) {
            snails.push(new Snail());
        }

        function frame() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            for (let i = 0; i < snails.length; i++) {
                snails[i].drawTrail(ctx);
            }

            for (let i = 0; i < snails.length; i++) {
                
                snails[i].draw(ctx);
            }
            

            
            for (let i = 0; i < Math.pow(speed.value,2); i++) {
                physicsFrame();
            }
            window.requestAnimationFrame(frame);
            
        }

        function physicsFrame() {
            for (let i = 0; i < snails.length; i++) {
                snails[i].update();
                for (let j = i + 1; j < snails.length; j++) {
                    snails[i].collide(snails[j]);
                }
            }
        }






        setTimeout(function() {
            window.requestAnimationFrame(frame);
        }, 50);
        function randomColor() {
    let r = Math.floor(Math.random() * 255);
    let g = Math.floor(Math.random() * 255);
    let b = Math.floor(Math.random() *255);
    return "rgb(" + r + "," + g + "," + b + ")";
}
        


   </script>

</HTML>